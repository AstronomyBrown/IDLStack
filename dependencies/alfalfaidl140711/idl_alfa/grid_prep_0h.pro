;+
; NAME:
; GRID_PREP
;
; SYNTAX:
;
; pro grid_prep_0h, grid, Tant=Tant, savepos=savepos, masterpos=masterpos
;
; DESCRIPTION:
;
; It prompts user for input parameters and produces one or more data cube grids.
; User can choose to input specific coord borders or grid center and size (in
; which case the box will be square). The program will either output a single
; grid of user specified nr of spectral channels (mode 1) or 4 grids of 1024
; spectral channels each (mode 2), covering approx
; a	-2000 to  3300 km/s  
; b	 2500 to  7900
; c	 7200 to 12800
; d	12100 to 17900
; The program prompts user for a grid label, e.g. 2332+27, and the grid structure
; (described below) is saved as an idl save file named grid_2332+27.sav (mode 1)
; or grid_2332+27a.sav,  grid_2332+27b.sav, grid_2332+27c.sav, grid_2332+27d.sav,
; respectively, in mode 2.
;
; OPTIONAL INPUT KEYWORDS:
;
;	Tant		Int - if set, no conversion from antenna temp to flux scale
;			is made; scale remains in K, as input in dred sets.
;			Useful for inspection of galactic HI maps
;	savepos		String - If set, the master pos file generated by posfind
;			is saved as an idl save file named by this keyword
;	masterpos=masterpos	String - if set, the program does not use posfind
;			to create a master pos file; instead it uses the file
;			indicated by this keyword 
;	rescale=rescale String - if set the program will seek "rescale.sav" files
;			in the directory of each observing session, to rescale the
;			data, equalizing beam-to-beam and pol-to-pol scales.
;			If rescale.sav files are unavailable and the keyword is
;			set, the program will bomb. 
;
; THE OUTPUT is up to 4 IDL .sav files, each containing a grid structure defined as:
;
; grid={name		str(64), a name for the grid picked by the user
;      RAmin, Decmin	min RA, Dec of grid map [hh.hhhh, dd.dddd]
;      DeltaRA,DeltaDec	grid step in RA (sec of time ) and in Dec (arcmin)
;	                NOTE THAT THE GRID POINT WITH THE LOWEST RA,DEC HAS
;	                RA=RAmin+DeltaRA/2., Dec=Decmin+DeltaDec/2
;      NX,NY		number of grid point in RA, in Dec
;      map_projection	string, describing the ttype of map projection
;      czmin		velocity of lowest vel channel of grid (km/s)
;      NZ		number of spectral channels in grid
;      velarr		velocity array 
;      wf_type		string(64) describing the type of weight function
;			used to grid
;      wf_fwhm		fwhm of grid function (arcmin)
;      han		int, nr of channels used to hansmooth spectral data
;			(1, 3, 5, 7)
;      medsubtract	if ne 0 then a median has been removed from each drift
;      baseline		structure containing the details of baselining process
;      		.nbase		intarr[2,NY] baseline polynomial order for given dec 
;				strip/pol; all spectra in one dec strip get same order
;		.coeff		double array[2,NX,NY,10] baseline coeffs
;				for each grid pt spectrum; max order=9
;      		.nreg		intarr[2,NY,40,4] boundaries of baseline regions
;				dim=2 		polarization
;				dim=NY		nr of Dec strip of grid points
;				dim=40		up to 40 regions per Dec strip
;				dim=4		llch,ll grid pt inx, urch, ur grid pt in RA of
;						baseline region EXCLUDED from baseline fit
;      calib_facs	fltarr(2,8,5) poly coeff of fits to conversion factors
;			to go from drift scan spectral units to grid map
;			dim=2 corresponds to polarizations
;			dim=8 corresponds to beam numbers
;			dim=5 corresponds to coeff, e.g. c0, c1, c2, c3, c4,
;				where coeffs refer to fit of conversion factors
;				as a function of time (modified Julian date)
;      grms		rms of spectral values over the whole grid
;      date		string, date when proc run 
;      who		name of person who produced this 
;      pos		pos structure array with all drifts contributing to grid map
;			there are as many array elements as there are drift scans 
;			contributing. Each array element has format:
;		.name		string, name of the drift scan
;		.scannumber	long integer
;		.posang		double, angle of the ALFA array, deg
;		.cenrahr	double, Ra in hrs at center of drift scan
;		.cendecdeg	double, Dec in deg at center of drift scan
;		.AZ0		double, azimuth angle in deg of bm0
;		.ZA0		double, zanith angle in deg of bm 0
;		.rahr		double array[600,8] RA positions of each rec/bm in scan
;		.decdeg		double array[600,8] Dec ositions of each rec/bm in scan
;		.cont		float array[2,600,8] continuum flux at given pol/rec/bm
;		.status		float array[2,600,8] status of given pol/rec/bm
;		.badbox		int array[100,2,8,4] corners of badboxes set by flagbb
;      drift_list	structure array containing list of drifts contributing, w/as many 
;			array elements as drift scans contributing; each record of array is:
;		.name		string, drift scan name
;		.scannumber	long, scan number
;		.cenrahr	double, Ra in hrs at center of drift scan
;		.cendecdeg	double, Dec in deg at center of drift scan
;      grid_makeup      structure array describing grid makeup, with as many elements as
;			there are grid points; each element of array contains:
;		.i		int index of grid pt in ra direction
;		.j		int index of grid pt in dec direction
;		.ra		double RA in hh.hhhhh of grid pt
;		.dec		double Dec in dd.dddd of grid pt
;		.driftname	string array[16} of up to 16 drift scans contributing
;				to flux at this grid pt
;		.scannumber	long array[16] of up to 16 drift scans contributing
;				to flux at this grid pt
;		.startrecnr	long[16,8] first rec in scan contributing to grid pt
;				for given beam
;		.stoprecnr	long[16,8] last rec in scan contributing to grid pt
;				for given beam
;		.date		string
;      d		fltarr[NZ,2,NX,NY] of grid spectral values
;			this IS the data cube
;      w		fltarr[NZ,2,NX,NY] of weights for each sp value
;      cont		fltarr[2,NX,NY] of continuum fluxes
;      cw               fltarr[2,NX,NY] of continuum weights
;
; It consists of a main program and a few subroutines.
; SUBROUTINE GRID_DISPLAY_IMG is used to display 2D drift maps
; SUBROUTINE GRID_HANNING can smooth spectra via han 3,5 or 7

;_________________________________________________________________
; PART 0 of GRID_PREP 
; obtains and checks input parameters, i.e.:
;	- RA_min, RA_max [hh.hhhh] of the output map
;	- Dec_min, Dec_max [dd.dddd] of the output map
;	- grid step in RA (sec of time) and in Dec (arcmin)
;	NOTE that the coords of the grid pixel with lowest RA, Dec
;	     are RA_min+RA_gridstep/2,Dec_min+Dec_gridstep/2
;	     and those with the highest RA, Dec are
;	     RA_max-RA_gridstep/2, Dec_max-Dec_gridstep/2 
;	- czmin (km/s), the lower vel for the output map, and
;	- nch_cube, the number of spectral channels to output
;	- w_fwhm the full width at half max of the Gaussian
;	  weight function used for the gridding, in arcmin
;	- hansmooth: 1,3,5 or 7, the spectral smoothing applied
;	  to the data before using for the gridding process
;	- medsubtract: if set, a median value is subtracted
;	  from each 2D drift map
;	- baseline: if set, interactive baselining of the data
;	  is invoked, before gridding

; After setting these parameters, PART 0 creates an array of
; positions for the grid: coord[0,i,j] are the RA values in hh.hhhh
; and                     coord[1,i,j] are the Dec values in dd.ddd
; for each point i,j of the grid.

;_______________________________________________________________________
; PART 1 of GRID_PREP
; uses the pos /st to:
; (a) make a drift_list /st which lists all drift scans fitting in
;     the grid box;
; (b) create a tmp_pos /st which contains only info from those drifts,
;     rather than the generic input pos, no longer used by this program
;     after tmp_pos is created. 
; Drift_list is an array of structures with size equal to the number
; of drift scans which have records within the grid box. The format
; of a drift_list record is:
;	drift_list.name		str, name of the drift scan
;	drift_list.scannumber	int, drift scan number
;	drift_list.cenrahr	flt, central RA of bm 0 of scan
;	drift_list.cendeg	flt, Dec of bm 0 of scan

; The array structure tmp_pos has as many pos records as there are in the
; drift_scan array structure. The format of a tmp_pos record is the same
; as that of that of a pos /st record.

;________________________________________________________________________
; PART 2 of GRID_PREP
; uses the tmp_pos and grid_list structures to produce a structure called
; "grid_makeup". This structure has a record for every point in the grid,
; which describes the data contributing to the flux at that grid point.
; A Grid_makeup record format is:
; 	grid_makeup.i		int, index in the ra direction of grid pt
;	grid_makeup.j		int, index in the dec direction of grid pt
;	grid_makeup.ra		flt, RA in hh.hhhh of the grid pt
;	grid_makeup.dec		flt, Dec in dd.ddd of the grid pt
;	grid_makeup.driftname	strarr of size [16], i.e. up to 16 different 
;				drift scans can contribute to the flux at
;				thsi grid point
;	grid_makeup.scannumber	intarr of size [16], see above
;	grid_makeup.startrecnr	intarr of size [nk,nb]=[16,8], giving the first
;				rec nr that contributes to flux at grid pt,
;				for beam nb of drift scan nk
;	grid_makeup.stoprecnr	intarr of size [nk,nb]=[16,8], giving the last
;				rec nr that contributes to flux at grid pt,
;				for beam nb of drift scan nk
;	grid_makeup.date	str, date of processing

; In this part of the program, we loop through the points of the grid.
; FOR EACH GRID POINT,
;	FIRST, we find all the records in tmp_pos of any scan - total number nd -  
;		that are in  vicinity (5 sec in RA, 5' in Dec) of the grid point. 
;		They are identified by 3 1D arrays
;		drindx (drift index), bmindx (beam index), recindx (rec index),
;		each of size nd; so, for i=0,nd-1, a record neighboring the given
;		grid point can be found at
;		ra  = tmp_pos[drindx[i]].rahr[recindx[i],bmindx[i]]
;		dec = tmp_pos[drindx[i]].decdeg[recindx[i],bmindx[i]]
;		The array "drindx" is repeated as many
;		times as there are recs and beams near the gridd pt;
;		an array "dr_nrs" is also made; it counts each drift only once, 
;		i.e. it contains only the unique list of drifts for that grd pt,
;		totalling ndr (ndr changes from a grid point to the next)
;	THEN, we loop through the ndr drift scans contributing to the current
;		drift scan, ans find which range of rec nrs corresponds, for
;		each beam, to a spectrum in vicinity of the grid point
;	FINALLY, we write to the grid_makeup structure

; Until this point, the only input used were the map parameters and the pos /st

; _________________________________________________________________________________
; PART 3 of GRID_PREP
; does the heavy-lifting grid  computational work, plus other things.
; One at a time, the drift scans contributing to the grid are loaded,
; by reference to the structure drift_list. 
; A "grid_map" 4D array is created, that will contain the spectral values
; of each grd pt, each pol (4096 x 2 x nr grd pts in X x nr grd pts in Y).
; A "weight_map" 4D array is also created, that will contain the total weight
; of each spectral value, by pol, by grid pt of the map.

; One at a time, drift scans in drift_list are loaded; each drift scan contributes
; to several (NN) grid points, with different weights. So for each grid
; point to which records of the the given drift scan contribute, weights are 
; computed (using the gridding weight function and the distance of each record
; from the grid point) and the weighted contribution of that drift scan is
; placed in the that grid point's bin. So, one drfit scan at a time, we build
; up the map.
;
; CODING HISTORY:
;
; RG = written May05
; RG - update 050616
; RG - major rewrite, 4D weight_map, etc. 050630
; RG - made output an all-including grid structure 22Sep05
; BK - added pos creation procedure 27Sep05
; RG - addded patch to take care of map areas w/o data  05Oct05
; BK - added continuum gridding 18Oct05
; BK - added continuum weights 27Oct05
; BK - added continuum fix to remove 12 second radar pulses  28Oct05
; BK - procedure checked and tested  4Nov05
; BK - tested and distributed 9Nov05
; RG - 	Major changes: corrected heliovelproj treatment, implemented 4 grids in one run,
;	corrected several errors in weigt assignment, implemented "rescale" option, 
;	implemented option to save masterpos or use existing masterpos, etc.
;	06feb14
; AS - added option to enter grid center as hhmm+dd, as well as
;      hh.hhh, dd.ddd 20Feb06
; AS - modified the display of the sky coverage to fix problem with
;      wrap-around at 0h.  14Jul06
;
; BK - added simple batch command line mode
; RG - modified to get around 0h effectively 25jan07
; RG - Entered ZA correction in Part 4 - 30aug08
; RG - Modified 1144-1153 and defntn of wmask, to account correctly for pos.status setting 24mar09
;***************************************************************************************

; SUBROUTINE TO DISPLAY THE 2D IMAGE

PRO grid_display_img,img,Np=Np,NS=NS,driftname=driftname,clip_max=clip_max,mapwindow

nrec=n_elements(img[0,*])
nchn=n_elements(img[*,0])
image=img
if (n_elements(clip_max) ne 0) then begin
  for nr=0,nrec-1 do begin
    indx=where(image[*,nr] gt clip_max,nind)
    if (nind gt 0) then image[indx,nr]=clip_max
  endfor
endif
  
window,/free,xsize=800,ysize=600, retain=2
loadct, 1
device, decomposed=0

mapwindow=!d.window
!p.multi=[0,2,1]
imgdisp,image,$
;        /histeq,$
        position=[0.05,0.05,0.95,0.95]
xyouts,nchn/2,nrec+12,'Beam, Pol ='+strtrim(string(ns),2)+', '+strtrim(string(np),2),size=1.5
xyouts,0,nrec+12,driftname,size=1.5
device, decomposed=0
;contour,mask2,thick=2,position=[0.05,0.05,0.95,0.95],$
;        c_colors='0000FF'XL,/overplot
yp=0
repeat begin
 yp=yp+100
 plots,[0,nchn-1],[yp,yp],linestyle=1
endrep until (yp gt nrec-100)
xp=0
repeat begin
 xp=xp+100
 plots,[xp,xp],[0,nrec-1],linestyle=1
endrep until (xp gt nchn-100)

end

;______________________________________________________________________

;SUBROUTINE TO SMOOTH THE IMAGE 
; GAUSAV is the HPFW of a gaussian in the rec direction
; HAN can be 3, 5 or 7, for Hanning smoothing in the spectral direction

pro grid_smoothing,image_raw,image_smo,gausav=gausav,han=han

nrec=n_elements(image_raw[0,*])
nchn=n_elements(image_raw[*,0])

image_smo=image_raw
if (gausav gt 1) then begin
  gausskernel=psf_Gaussian(NPIXEL=41, FWHM=gausav,$
                           NDIMEN=1, /NORMALIZE)
  for i=0,nchn-1 do begin
    smoothedsample=convol(reform(image_raw[i,*]),gausskernel, /EDGE_TRUNCATE)
    image_smo[i,*]=reform(smoothedsample,1,nrec)     
  endfor
endif
image_smo2= image_smo
if (han gt 1) then begin
  if (han eq 3) then hansm=[0.5,1.,0.5]/2.
  if (han eq 5) then hansm=[0.25,0.75,1.,0.75,0.25]/3.
  if (han eq 7) then hansm=[0.146,0.5,0.854,1.,0.854,0.5,0.146]/4.
  for nr=0, nrec-1 do begin
    smoothedspec = convol(reform(image_smo[*,nr]),hansm,/edge_truncate)
    image_smo2[*,nr] = smoothedspec
  endfor 
endif

image_smo = image_smo2

end

;______________________________________________________________________

;Simple procedure to remove 12 second radar; BK addition

pro continuumfix, cont_pt

for ipol=0,1 do begin
   for ibeam=0,6 do begin

	y=fft(cont_pt[ipol,*,ibeam], -1)
	y=reform(y)
	xvals=[50,100,150,200,250,300,350,400,450,500,550]
	range=8

	for k=0,n_elements(xvals)-1 do begin

	    x=findgen(2*range+1)+xvals[k]-range
	    result=interpolate([y[xvals[k]-range],y[xvals[k]+range]],x)
	    y[xvals[k]-range:xvals[k]+range]=result

	endfor

        cont_pt[ipol, *, ibeam]=real_part(fft(y,1))

   endfor

endfor

end



;______________________________________________________________________

;Procedure to do the frequency shifting in Fourier space; AS addition

pro freqshift,dx,spec_in,spec_out

  i=dcomplex(0,1)
  ddx=dx*(-1.) 	; correction by rg/25feb06
 
  n=n_elements(spec_in)  

  ;create array of indices
  indarr=dindgen(n)
  indarr[(n/2):n-1]=(-1)*reverse(dindgen(n/2))

  ;calculate fourier transform of shifted spectrum
  ffts=fft(spec_in)*exp(2.0*!pi*i*ddx*indarr/double(n))

  ;do the inverse transform to get back the shifted spectrum
  spec_out=(fft(ffts,/INVERSE))
  spec_out=real_part(spec_out)

end


;______________________________________________________________________
; MAIN PROGRAM


;***************************************************************************
pro grid_prep_0h, grid, Tant=Tant, savepos=savepos, masterpos=masterpos, rescale=rescale, $
    batch=batch, bxcencoords=bxcencoords, bxsize=bxsize, dgdecmin=dgdecmin, $
    w_fwhm=w_fwhm, gname=gname, who=who
;***************************************************************************


Print, 'Version 8.0 -- Feb 06'
!p.multi=0
t00=systime(1)

;PART 0. Check parameters & keywords

if (n_elements(batch) eq 0) then begin

ramin=0.D
ramax=0.D
decmin=0.D
decmax=0.D
dgra=0.D
dgdec=0.D
dgrasec=0.D
dgdecmin=0.D
rbxcen=0.D
dbxcen=0.D
bxsize=0.D
cosdec=0.D

Print,'Enter runmode: 4 square grids (mode=4) or 1 grid of specified box limits (1)?'
read,runmode
if (runmode eq 1) then begin
  print,'Enter RA_min, RA_max [hh.hhhhh] of box'
  read,ramin,ramax
  print,'Enter Dec_min, Dec_max [dd.ddddd] of box'
  read,decmin,decmax
  cosdec=cos(((decmax+decmin)/2.)*!PI/180.)
endif else begin
  askforcoords:
  bxcencoords='temp'
  print,'Enter box center: hhmm+dd OR hh.hhhh, dd.dddd'
  read,bxcencoords
  poscoma=strpos(bxcencoords,',')
  if (poscoma gt 0) then begin
    rbxcen=float(strmid(bxcencoords,0,poscoma))
    dbxcen=float(strtrim(strmid(bxcencoords,poscoma+1),2))
  endif else begin
    posplus=strpos(bxcencoords,'+')
    if (posplus lt 0) then begin
      print,'The format of the coordinates is not compatible.  Please try again.'
      goto,askforcoords
    endif
    rbxcenhours=float(strmid(bxcencoords,0,2))
    rbxcenmins=float(strmid(bxcencoords,2,2))
    rbxcen=rbxcenhours+rbxcenmins/60.
    dbxcen=float(strtrim(strmid(bxcencoords,posplus+1),2))
  endelse
  print,'Box will be square. Enter box size: dd.dddd'
  read,bxsize
  decmin=dbxcen-bxsize/2.
  decmax=dbxcen+bxsize/2.
  cosdec=cos(dbxcen*!PI/180.)
  rarange=(bxsize/15.)/cosdec
  ramin=rbxcen-rarange/2.
  ramax=rbxcen+rarange/2.
  domapflag=intarr(4)+1
  PRINT,'Four grid files will be produced, each of 1024 sp. chans...'
  Print,'Do you wish to skip any of them? [y/n def=n]'
  ans=''
  read, ans
  if (ans eq 'y' or ans eq 'Y') then begin
    print, 'Enter 4 integers: 0 for map to skip, 1 for map to process'
    print, '  e.g. you wish to skip map c; enter 1,1,0,1'
    read,domapflag
  endif
endelse
print,'Enter grid step in Dec [arcmin]'
read,dgdecmin
dgrasec=dgdecmin*4.0/cosdec
Print,'... the equivalent grid step in RA is :',dgrasec,' sec of time. OK? [y/n def=y]'
ans=''
read,ans
if (ans ne 'y' and ans ne 'Y' and ans ne '') then begin
  Print,'... then enter your own RA grid step in sec of time'
  read,dgrasec
endif
dgra=dgrasec/3600.
dgdec=dgdecmin/60.
Epoch=2000.0

if (runmode eq 1) then begin
  print,'Enter czmin [km/s], and number of sp. chans in cube'
  print,'      (e.g. 500,800 will cover from cz=500 to about 4700)'
  read,czmin1,nch_cube1
  nch_cube1=round(nch_cube1)
endif
print,'Enter FWHM of weight function (arcmin)'
read,w_fwhm
w_fwhm_hrs=(w_fwhm/(60*15.))/cosdec
w_fwhm_deg=w_fwhm/60.
sigma=0.4247*w_fwhm_deg*!PI/180.
print,'Enter name of the output grid file (up to 64 chars)'
gname=string(64)
read,gname
print,'Enter your name or initials'
who=''
read,who

hansmooth=1	;WILL NEED TO BE SET INTERACTIVELY
medsubtract=0	;WILL NEED TO BE SET INTERACTIVELY

endif

;BK added January 4, 2007
;Quick run for batch mode - use this with caution.  Automation is
; not to be taken lightly...

if (n_elements(batch) ne 0) then begin
 runmode=4
 posplus=strpos(bxcencoords,'+')
 rbxcenhours=float(strmid(bxcencoords,0,2))
 rbxcenmins=float(strmid(bxcencoords,2,2))
 rbxcen=rbxcenhours+rbxcenmins/60.
 dbxcen=float(strtrim(strmid(bxcencoords,posplus+1),2))
 decmin=dbxcen-bxsize/2.
  decmax=dbxcen+bxsize/2.
  cosdec=cos(dbxcen*!PI/180.)
  rarange=(bxsize/15.)/cosdec
  ramin=rbxcen-rarange/2.
  ramax=rbxcen+rarange/2.
  domapflag=intarr(4)+1
PRINT,'Four grid files will be produced, each of 1024 sp. chans...'

dgrasec=dgdecmin*4.0/cosdec
Print,'... the equivalent grid step in RA is :',dgrasec,' sec of time.  If this is not OK, do not run in batch!'
dgra=dgrasec/3600.
dgdec=dgdecmin/60.
Epoch=2000.0

w_fwhm_hrs=(w_fwhm/(60*15.))/cosdec
w_fwhm_deg=w_fwhm/60.
sigma=0.4247*w_fwhm_deg*!PI/180.

hansmooth=1	;WILL NEED TO BE SET INTERACTIVELY
medsubtract=0	;WILL NEED TO BE SET INTERACTIVELY

endif

;----------------------------------------------------
;----------------------------------------------------
;;Added by B. Kent September 27, 2005
;;This element will spawn and obtain the most recent master list of
;;the position structures.  pos does not need to be passed to the
;;program any longer.  It creates a masterpos/masterdir listing

If (n_elements(masterpos) eq 0) then begin
  print, 'Creating position structure... '

  print, rbxcen, dbxcen
  posfind, pos, masterdir,ramin=rbxcen,decmin=dbxcen,/loadpos  ;modfied April 17,2006
endif else begin
  print,'Restoring masterpos,masterdir from file: ',masterpos
  restore,masterpos
  print,'Restored masterpos has n_elements: ',n_elements(pos)
endelse
If (n_elements(savepos) ne 0) then save,pos,masterdir,file=savepos

;----------------------------------------------------


Dra=ramax-ramin
if (ramin gt ramax) then Dra=ramax+24.-ramin	; i.e. we're crossing 0 hrs
Ddec=decmax-decmin
NX = round(Dra/dgra)
NY = round(Ddec/dgdec)

coord=dblarr(2,NX,NY)     ; MAKE coord array
ra=dindgen(NX)
dec=dindgen(NY)
ra=ra*dgra +ramin+dgra/2.
nnn=where(ra gt 24.0,nnnn)
if (nnnn gt 0) then ra[nnn]=ra[nnn]-24.	; when crossing 0 hrs
dec=dec*dgdec+decmin+dgdec/2.
for i=0,NX-1 do begin
  coord[0,i,*]=ra[i]
endfor
for j=0,NY-1 do begin
  coord[1,*,j]=dec[j]
endfor

;...............................................................................
;PART 1. Go find all the drifts partly fitting within box
;	- make a drift_list structure listing those
;	- and create a tmp_pos which contains only info from those drifts,
;	  rather than the generic input pos, no longer used by this program
;	  after tmp_pos is created.

ndrpos=n_elements(pos)

flag_up=0
ramind=(ramin-2.5*w_fwhm_hrs)*15.*!PI/180.	; lowest ra at which we need data
ramaxd=(ramax+2.5*w_fwhm_hrs)*15.*!PI/180.	; highest ra at which we need data
racend=(ramaxd+ramind)/2.
decmind=(decmin-2.5*w_fwhm_deg)*!pi/180.
decmaxd=(decmax+2.5*w_fwhm_deg)*!pi/180.
deccend=(decmind+decmaxd)/2.

for i=0,ndrpos-1 do begin
  rapc=pos[i].cenrahr		; RA of center of drift for bm 0
  decpc=pos[i].cendecdeg	; dec of center of drift for bm 0
  rapcrad=rapc*15.*!PI/180.
  decpcrad=decpc*!pi/180.
  
; USE polarity of sin, to get around 0hrs wrap

  if (abs(sin(rapcrad)-sin(racend)) lt 0.055 and abs(sin(decpcrad)-sin(deccend)) lt 0.024) then begin
    record={name:pos[i].name, $
            scannumber:pos[i].scannumber, $
            cenrahr:pos[i].cenrahr, $
            cendecdeg:pos[i].cendecdeg}
    rec_pos=pos[i]
    if (flag_up eq 0) then begin
      drift_list=record
      tmp_pos=rec_pos
    endif else begin
      drift_list=[drift_list,record]
      tmp_pos=[tmp_pos,rec_pos]
    endelse
    flag_up=1
  endif
endfor

map_ndrift=n_elements(drift_list)

print, ' '
print,n_elements(drift_list),' drifts found to contribute from grid_prep procedure.'
print,drift_list.name,format='(3a30)'
print, ' '  


; PART 1.2 - added by B. Kent
; moved from 2.2 to 1.2 and modified to wrap-around 0h by AS 07/14/06
;Plot the defined box and over plot the drifts
window, /free, retain=2, xsize=800, ysize=800

;Set window
hor, ramax+1.0/15.0, ramin-1.0/15.0
ver, decmin-1.0, decmax+1.0

;Plotting space
device, decomposed=1
plot, [0,0],[0,0], /nodata, xtitle='RA [Hrs]', ytitle='Dec [Deg]', $
  title='Map center at RA: '+strcompress((ramin+ramax)/2.0)+', Dec: '$
  +strcompress((decmin+decmax)/2.0)

;Display box
tvboxbk, [ramax-ramin, decmax-decmin], ramin+(ramax-ramin)/2.0, decmin+(decmax-decmin)/2.0, $ 
/data, color='0000FF'XL

;Overplot drifts
pos2=pos
for i=0, map_ndrift-1 do begin
     dirindex=where(pos.name eq drift_list[i].name)
     if (ramax gt 24. and ramin lt 24.) then begin      
       indratemp=where(pos2[dirindex].rahr lt 1.,numberevents)
       if (numberevents gt 0) then pos2[dirindex].rahr[indratemp]=pos2[dirindex].rahr[indratemp]+24. 
     endif
     if (ramax gt 0. and ramin lt 0.) then begin      
       indratemp=where(pos2[dirindex].rahr gt 23.,numberevents)
       if (numberevents gt 0) then pos2[dirindex].rahr[indratemp]=pos2[dirindex].rahr[indratemp]-24. 
     endif
     for j=0, 6 do oplot, pos2[dirindex].rahr[*,j], pos[dirindex].decdeg[*,j], color='00FF00'XL
endfor
delvarx,pos2

;...............................................................................
;PART 2. Go loop through each grid point and identify drifts/recs that sweep 
;       close enough to make a contribution to the signal at that grid pt.
;	Here we loop through each grid point and find first the drifts that
;	due to vicinity can contribute to the grid point. 
;	Once identified the drift scans that contribute to that grid point,
;	we loop through them to find the records in each drift that are near.
;	The exercise could be done in a single "where" for each grid point,
;	but keeping track of the indices gets messy, so I break the process
;	in two stages.
;	FOR EACH GRID POINT:
;		FIRST, we find all the records - total number nd - in tmp_pos 
;			that are in  vicinity of the grid point. They are 
;			identified by 3 1D arrays
;			drindx, bmindx,recindx,  each of size nd
;			so, for i=0,nd-1, a record neighboring the given
;			grid point can be found at
;			ra  = tmp_pos[drindx[i]].rahr[recindx[i],bmindx[i]]
;			dec = tmp_pos[drindx[i]].decdeg[recindx[i],bmindx[i]]
;		THE ARRAY drindx repeats the name of a given drift as many
;			times as there are recs and beams in it near the grd pt
;			so the array dr_nrs counts each drift only once, i.e.
;			it contains only the unique list of drifts for that grd pt
;		NEXT, we create a structure GRID_MAKEUP. This is an array of
;			structures with as many elements as there are grid points
;			in the map. For each grid point, GRID_MAKEUP lists 
;			- the grid coords (i,j,ra and dec)
;			- up to 16 drift names, drift scannumbers
;			- and for each of the up to 16 drifts 
;			  the start scan nr and stop scan nr
;			  of a sequence of neighboring records, 
;			  separately for each beam of the drift.
;			  GRID_MAKEUP allows up to 16 different drifts to contribute
;			  to a given grid point, which is OK for ALFALFA but may
;			  fall short if this is used for deeper mapping with multiple
;			  passes. Since this is an internal structure not carried
;			  through in further processing, it is an easily correctable
;			  feature.
;		THIS CONCLUDES the preliminary work with the pos structure.
;			
; Q:WHAT DO WE DO IF THERE ARE NO DATA IN SPECIFIED VICINITY OF GRID PT? ==> see "IF ND=0, THEN..."

icount=0
N_nodata=0
rarad=ra*15.*!PI/180.

for i=0,NX-1 do begin
  icount=icount+1
  if (icount eq 20) then begin
    print,i,' columns processed'
    icount=0
  endif
  for j=0,NY-1 do begin
    index=where(abs(sin(tmp_pos.rahr*15.*!PI/180.)-sin(rarad[i])) lt 1.454e-3 and 	$
                abs(tmp_pos.decdeg-dec[j]) lt 0.083333,nd)
;               index has as many values as there are records -of any drift -
;               within both 20 sec in ra and 5' in dec from the grid pt [i,j]
;   IF ND=0 THEN...
    if (nd eq 0) then begin
      record_MAKEUP={i:i,j:j, 	$
		  ra:ra[i],	$
		  dec:dec[j], 	$
		  driftname:strarr(16), $
		  scannumber:lonarr(16), $
		  startrecnr:lonarr(16,8), $
		  stoprecnr:lonarr(16,8), $
		  date:systime(0)}
      N_nodata=N_nodata+1
      goto,write_to_makeup
    endif
    dims=size(tmp_pos.rahr,/dimensions)
    nrec=dims[0]			; this is the usual # of rec in a drift, i.e. 600
    recindx=index mod nrec
    bmindx=index/600 mod dims[1]        ; dims[1] is =8
    drindx=index/(nrec*dims[1])		; recindx,bmindx and drindx are 1D arays
    					; tmp_pos[drindx].rahr[recindx,bmindx] 
                                        ; is near ra[i],dec[j]
    dr_nrs=drindx(uniq(drindx))		; unique drift indx (in tmp.pos) of the 
                                        ; drifts contributing to grid pt
    ndr=n_elements(dr_nrs)		; total nr of unique drifts contribtng to grid pt
;    PRINT,I,J,ND,NDR,ra[i],dec[j]
    driftname=strarr(16)			; Initialize
    scannumber=lonarr(16)
    startrecnr=lonarr(16,8)
    stoprecnr=lonarr(16,8)
    for k=0,ndr-1 do begin		; loop through the ndr unique drifts 
                                        ; for this grid pt
      driftname[k]=tmp_pos[dr_nrs[k]].name
      scannumber[k]=tmp_pos[dr_nrs[k]].scannumber
      index2=where(abs(sin(tmp_pos[dr_nrs[k]].rahr*15.*!PI/180.)-sin(rarad[i])) lt 1.454e-3 and $
                   abs(tmp_pos[dr_nrs[k]].decdeg-dec[j]) lt 0.083333,nd)
;     repeat this vicinity calculation b/c it's fast and simplifies code read
      recindx=index2 mod nrec		
;     1D array of rec nrs, for each rec in drift that counts to grid pt
      bmindx =index2/nrec		
;     1D array of bm nrs, for each rec in drift that counts to grid pt
      bm_nrs=bmindx[uniq(bmindx)]	
;     set of unique bm indices in this drift contribtng to grid pt
      n_bms=n_elements(bm_nrs)
;      PRINT,'     ',K,N_BMS,DRIFTNAME      
;     and now loop through the beams in this drift and find the start and stop rec nrs
      for n=0,n_bms-1 do begin
        beamnr=bm_nrs[n]
        indxb=where(bmindx eq bm_nrs[n],nbb)
        startrecnr[k,beamnr]=recindx[indxb[0]]
        stoprecnr [k,beamnr]=recindx[indxb[nbb-1]]
;        PRINT,'             ',N,BEAMNR,STARTRECNR[BEAMNR],STOPrecNR[BEAMNR]
      endfor
    endfor
    record_MAKEUP={i:i,j:j, 	$
		  ra:ra[i],	$
		  dec:dec[j], 	$
		  driftname:driftname, $
		  scannumber:scannumber, $
		  startrecnr:startrecnr, $
		  stoprecnr:stoprecnr, $
		  date:systime(0)}
    write_to_makeup:
    if (i eq 0 and j eq 0) then begin
      GRID_MAKEUP=record_MAKEUP
    endif else begin
      GRID_MAKEUP=[GRID_MAKEUP,record_MAKEUP]
    endelse
  endfor
endfor



;...........................................................................................
;
; PART 3. Loading the data files
;	Here we load the data files, one drift scan at a time, referring to
;	the drift_list structure created in PART 1. We process the data
;	of each drift, "filling" with its contribution the bin of each
;	grid pt that's appropriate.
;	The final products are: 
;	- a grid_map	a 4D array of spectral values (spec ch, pols, grid pt X, grid pt Y)
;	- a weight_map	a 4D array of weights, same dimensionality as grid_map 

; 2 arrays of (4096,2,NX,NY) require too much memory, 2 Gb cannot do it. Must break processing
; into 4 sequential parts. Bummer...!


t30=systime(1)
print,t30-t00,' seconds runtime; now starting to loop through drift scans'
nrsec=4
ichstart=lonarr(4)
ichstop =lonarr(4)
vlow=[-2000.,2500.,7200.,12100.]
nchcube=1024
qual=[gname+'a',gname+'b',gname+'c',gname+'d']

if (runmode eq 1) then begin
  qual=gname
  vlow=czmin1
  nrsec=1
  nchcube=nch_cube1
endif

; Loop of 1 or 4 grids (depending on runmode) starts here

for isec=0,nrsec-1 do begin
  if (domapflag[isec] eq 0) then continue	; i.e. skip this loop iteration
  weight_map=fltarr(nchcube,2,NX,NY)	; array of weights for the new grid
  grid_map=fltarr(nchcube,2,NX,NY)	; array of new grid values
  cont_map=fltarr(2,NX,NY)                ; array of new continuum values  ;---> Added by B. Kent
  cont_weight_map=fltarr(2,NX,NY)         ; array of continuum weights     ;---> Added by B. Kent

; Here start big loop through each drift in drift_list
;...........................................................................................

for idr=0,map_ndrift-1 do begin			; loop through each drift in drift_list; 
						; loop ends just before "PART 4" , line ~1127
  
  driftname=drift_list[idr].name
  dirindex=where(pos.name eq drift_list[idr].name)
  driftfilepath=masterdir(dirindex)+driftname
  indx=where(grid_makeup.driftname eq driftname,NN)	

; NN is the number of grid pts to which this drift idr contributes

  dims=size(grid_makeup.driftname,/dimensions)		
  n_entries=dims[0]
  indx_entry=indx mod n_entries		

; a given grid pt can be affected by up to 16 scans (grid_makeup.driftname is [16,NX*NY]);
; indx_entry is a 1D array of NN elements, one nr - 0 to 15 - for each grid pt affected by 
; scan idr, revealing the ordinal location in the list of 16 for that grid pt this scan takes

  indx_grdpt=indx/n_entries		

; index_grdpt is the index - a nr b/w 0 and NX*NY-1 - identifying the grid pts affected
; by scan idr 

  restore,file=driftfilepath[0]
  print,idr,' processing file:',driftname,' affects ',NN,' grid pts'
  print,idr,' grid '+qual[isec]+';  file located at '+driftfilepath[0]
; next:
;- rescale calibration
;- read pos.badbox and either replace bb with NaN, noise or interpolate
;- shift all spectra in drift to standard freq range
;- restrict spectra to desired channel range between vmin and vmax
;- smooth all spectra in drift
;- baseline all spectra in drift

  nrec=n_elements(dred[0,*,0])
  nbm=n_elements(dred[0,0,*])
  nchn=n_elements(dred[0,0,0].d)


; PART 3.1	Rescale Calibration
;		Several correction here:
;	1) if keyword rescale is set, then use rescale files to equalize
;	   pols and beams to avg values. Note that for this to work, there
;	   must be a single 'rescale.sav' file in each data directory from
;	   which drifts are being read. When multiple rescale files are
;	   present in the directory, user must consolidate them into a 
;	   single one.
;	2) convert antenna temperature to flux, unless keyword Tant is set,
;	   in which case scale is retained in K
;	3) correct fro ZA dependence of gain
; 	4) remove 12 sec radar burst from continuum scan

; Part 3.1.1

  if (n_elements(rescale) ne 0) then begin
    rescalefilepath=masterdir(dirindex)+'rescale.sav'
    restore,file=rescalefilepath
    zeromask=fltarr(4096)
    zeromask[3480:3520]=1.
    zeromask[3480:3489]=[0.,.1,.2,.3,.4,.5,.6,.7,.8,.9]
    zeromask[3511:3520]=[.9,.8,.7,.6,.5,.4,.3,.2,.1,0.]

    for nb=0,6 do begin
      zero=fltarr(4096)
      zero[3480:3520]=pol_zero[*,nb]
      zerohalf=zero*zeromask/2.
      for nr=0,nrec-1 do begin
        dred[0,nr,nb].d=(dred[0,nr,nb].d-zerohalf)*av_polcor[nb]*av_bmcor[nb]
        dred[1,nr,nb].d=(dred[1,nr,nb].d+zerohalf)*(av_polcor[nb]/(2.*av_polcor[nb]-1.))*av_bmcor[nb]
      endfor
    endfor
  endif

; Part 3.1.2

  mjd=dred[0,300,0].hf.mjd_obs	; mod Julian Date at center of drift
  cal_Jy=fltarr(2,8)+1.		; factors to convert pol/bm scale to Jy
;  cal_fx=1.			; here define (or read from table) cal factors
  cal_Jy[*,0]=1000./11.
  cal_Jy[*,1:7]=1000./8.6
; BUT SEE PART 4, WHERE WE MUST TAKE INTO ACCOUNT THE GAIN DILUTION DUE TO W_FWHM
  If (n_elements(Tant) ne 0) then cal_Jy=fltarr(2,8)+1.	; i.e. do not convert to Jy

; Part 3.1.3

  cal_gain=fltarr(2,8)+1.	; factors to correct for gain(ZA) - TBD
  
; Part 3.1.4
; Apply continuum fix to remove the 12-second radar from the continuum

  continuumfix, cont_pt    ;---> line Added by B. Kent
  cont_pt_wrk=cont_pt       ;---> line Added by B. Kent

  for np=0,1 do begin
    for nb=0,nbm-1 do begin
      fx=cal_Jy[np,nb]*cal_gain[np,nb]
      dred[np,*,nb].d=dred[np,*,nb].d*fx
      cont_pt_wrk[np,*,nb]=cont_pt[np,*,nb]*fx   ; line added by B. Kent
    endfor
  endfor

; PART 3.2	Hanning smooth if desired

  if (hansmooth eq 1) then begin
    hansmo=[0.5,1.,0.5]/2.
    for ip=0,1 do begin
      for ib=0,nbm-1 do begin
        for ir=0,nrec-1 do begin
          dred[ip,ir,ib].d = convol(reform(dred[ip,ir,ib].d),hansmo,$
                      /EDGE_TRUNCATE,/NAN,MISSING=0)
        endfor
      endfor
    endfor
  endif

; PART 3.3	Get pos.badbox and create 4D mask wmask, and if MEDSUBTRACT=1 &
;		if badbox extends through whole drift (permanent RFI
;		feature), subtract the median within badbox from all spectral
;		data in given bm, pol 

  posindx=where(pos.name eq driftname)
  wmask=fltarr(nchn,2,nrec,nbm)+1.   ; changed from wmask=bytarr(nchn,2,nrec,nbm)+1B on 24mar09/rg

  for np=0,1 do begin
    for nb=0,nbm-1 do begin
      inbb=where(total(reform(pos[posindx].badbox[*,np,nb,*]),2) ne 0,nbb)
      for ibb=0,nbb-1 do begin
        llch=pos[posindx].badbox[inbb[ibb],np,nb,0]
        urch=pos[posindx].badbox[inbb[ibb],np,nb,2]
        if (llch gt urch) then begin    ;next 5 lines added by AS on 08/03/2006
           templlch=llch
           llch=urch
           urch=templlch
        endif
        llrec=pos[posindx].badbox[inbb[ibb],np,nb,1]
        urrec=pos[posindx].badbox[inbb[ibb],np,nb,3]
        if (urrec ge nrec) then urrec=nrec-1            ; PLUG FOR BAD POS FILES
        wmask[llch:urch,np,llrec:urrec,nb]=0.
	if (medsubtract eq 1 and llrec eq 0 and urrec eq nrec-1) then begin
          bmpolmed=MEDIAN(reform(dred[np,*,nb].d),Dimension=2,/EVEN) ; 1D spec
          for ir=0,nrec-1 do begin
            dred[np,ir,nb].d[llch:urch]=bmpolmed[llch:urch]
          endfor
        endif
      endfor
    endfor
  endfor


; PART 3.4  Shift all spectra in drift so that vhel=7663 is in ch 2047, counting from 0
;	********     change from 2048 to 2047 made on 22Feb06, after PP's tests
;	    must compute heliovel for each record, else ~ 1km/s shifts are missed
;	LATER: DO THE CORRECTION IN FOURIER DOMAIN, RATHER THAN USING INTERPOLATE


  for nr=0,nrec-1 do begin

    heliovelproj=dred[0,nr,0].h.pnt.r.heliovelproj*299792.458
    heliovelused=dred[0,0,0].h.dop.velobsproj	;immaterial for our computations
    cenfrq_used=dred[0,nr,0].hf.rpfreq
    deltaf=-1420.4058*dred[0,nr,0].h.pnt.r.heliovelproj
    delta_ch=deltaf/0.024414063	;this frq shift puts 1385 at ch 2047, in helio ref frame 
    xshifted=findgen(nchn)-delta_ch

    for nb=0,6 do begin
      for np=0,1 do begin

        spec=dred[np,nr,nb].d
;        result=interpolate(spec,xshifted,cubic=-0.5)
;        result=interpolate(spec,xshifted)
        freqshift,delta_ch,spec,result
        maxval0=max(reform(dred[np,nr,nb].d[3490:3510]),mindex0)
        dred[np,nr,nb].d=result
; 		Shift also the wmask
        wm=wmask[*,np,nr,nb]
        wmask[*,np,nr,nb]=interpolate(wm,xshifted)

      endfor    ; end of np loop
    endfor	; end of nb loop

    if (nr eq nrec/2) then begin
      frqarr=cenfrq_used+(findgen(nchn)-2047)*0.024414063
      velarr=299792.458*(1420.4058/frqarr -1.) 
;     which should place vhel=7663 at ch 2047, counting from 0
;     change from 2048 to 2047 made on 22Feb06, after PP's tests
;     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    endif

  endfor   	; end of nr loop   

; PART 3.5 	Restrict to spectral chnl interval ichstart[isec] to ichstop[isec]

  res=min(abs(velarr-vlow[isec]),chindx)
  ichstop[isec] =chindx
  ichstart[isec]=chindx-(nchcube-1)

;  d_cube=dred[*,*,*].d[ichstart[isec]:ichstop[isec]]
;  wmask_cube=wmask[ichstart[isec]:ichstop[isec],*,*,*]



; PART 3.6	Loop through al grid pts to which given drift makes a contribtn
;		FOR EACH GRID PT AFFECTED BY THE DRIFT:
;		- remind us which beams and, for each beam, which rec nrs are relevant
;		- remind us the i,j and ra,dec of the grid pt
;		- THEN LOOP through all beams, and if bm contrbts,
;			- LOOP through the recs that contribute
;			  	compute distance of each rec from grd pt
;				assign a "position" weight pweight
;				set wmask=0 or low fraction (1/pos.status) if the pos.status for record is flagged bad
;				add spectrum to the grd pt bin, weighted by pweight and wmask
;				add pweight*wmask to the weight_map bin of the grid pt

  frstrec=lonarr(8)		;define type
  lastrec=lonarr(8)

  for ngr=0,NN-1 do begin	; loop through all grid points to be affected by drift idr

    entry_nr=indx_entry[ngr]	; which location (of 16) corresponds to drift idr grid pt # ngr
    grdpt_nr=indx_grdpt[ngr]	; which index in grid_makeup corresponds to grid pt # ngr
    frstrec=grid_makeup[grdpt_nr].startrecnr[entry_nr,*]  ; 8-array of first rec to use
    lastrec=grid_makeup[grdpt_nr].stoprecnr[entry_nr,*]	  ; 8-array of last rec to use 
    igrd=grid_makeup[grdpt_nr].i	; grid location of grid pt ngr
    jgrd=grid_makeup[grdpt_nr].j	; grid location of grid pt ngr

;   WHAT IF THERE IS NO DATA NEAR THE GRID PT? ==> SET WEIGHT_MAP TO ZERO

    if (total(grid_makeup[grdpt_nr].scannumber) eq 0) then begin
      weight_map[*,*,igrd,jgrd]=0.
      cont_weight_map[*,igrd,jgrd]=0.      ; line added by B. Kent
      goto, endof_gridpt_loop
    endif

    indx_bm=where(lastrec ne 0,nbmcontrb)	; beam tracks that will affect grid pt ngr
    ragrdpt=grid_makeup[grdpt_nr].ra*15.*!PI/180.	; ra of grid pt in rad
    decgrdpt=grid_makeup[grdpt_nr].dec*!PI/180.		;dec of grid pt in rad
    cosdec=cos(decgrdpt)

    for nb=0,nbmcontrb-1 do begin 	; loop through all beam tracks contributing

      near_bm=indx_bm(nb)	; note that the near beam is near_bm, not nb
      if (indx_bm[nb] eq 7) then goto, endofnbloop	; skip the lame "beam"

      for nr=frstrec[near_bm],lastrec[near_bm] do begin	

	  ; loop through the recs found in vicinity of grid pt
;        spec=d_cube[*,*,nr,near_bm]	; spectrum (2 pols: nchcube x 2) of rec nr, beam nb
        spec=dred[*,nr,near_bm].d[ichstart[isec]:ichstop[isec]]	; spec of (nchcube x 2 pol) 

        cont=cont_pt_wrk[*,nr,near_bm]  ; continuum point (2 element fltarr) Added by B. Kent

        raspec=dred[0,nr,near_bm].rahr*15.*!PI/180.	; ra of spectrum above
        decspec=dred[0,nr,near_bm].decdeg*!PI/180.
        delra=(raspec-ragrdpt)*cosdec
        dist2=((sin(raspec-ragrdpt)*cosdec))^2+(decspec-decgrdpt)^2 ; ang sep bw rec and grid pt
        pweight=exp(-0.5*(dist2/sigma^2))	; weight due to vicinity alone

;	if you're keeping antenna temp scale, gain of bm 0 does not play;
;	if you're converting to flux density, gain of beam 0 yields higher weight:
        if (n_elements(Tant) eq 0 and near_bm eq 0) then pweight=1.27*pweight

; for loop below modified on 20mar09/rg; also modified wmask from bytarr to fltarr, above
        for ip=0,1 do begin
          ind0= where(wmask[ichstart[isec]:ichstop[isec],ip,nr,near_bm] eq 0,nnn0) 
;         i.e. save the chans where wmask already been set to zero via badboxes
          if (pos[posindx].status[ip,nr,near_bm] gt 1) then $
             wmask[ichstart[isec]:ichstop[isec],ip,nr,near_bm]=1./pos[posindx].status[ip,nr,near_bm]
          if (pos[posindx].status[ip,nr,near_bm] ge 10) then $
             wmask[ichstart[isec]:ichstop[isec],ip,nr,near_bm]=0.
	  ; and reset to zero, in case status overlapped a badbox and set it to a low, >0 value
          if (nnn0 gt 0) then wmask[ind0,ip,nr,near_bm]=0.
        endfor

        wm=reform(weight_map[*,*,igrd,jgrd])
        wmc=reform(wmask[ichstart[isec]:ichstop[isec],*,nr,near_bm])
        gm=reform(grid_map[*,*,igrd,jgrd])

        wm = wm +pweight*wmc
        gm = gm +pweight*spec*wmc

        weight_map[*,*,igrd,jgrd] = wm
        grid_map[*,*,igrd,jgrd] = gm
        
        cont_weight_map[*,igrd,jgrd]=cont_weight_map[*,igrd,jgrd]+pweight ;Added by BK
        cont_map[*,igrd,jgrd]=cont_map[*,igrd,jgrd]+cont[*]*pweight       ;Added by BK

      endfor

    endofnbloop:
    endfor

  endof_gridpt_loop:
  endfor

endfor		; end of idr loop through drift_list
  

;.............................................................................................        
; PART 4	Divide grid_map by weight_map, and:
;	Keep in mind that the "synthesized beam" area has been increased with respect 
;	to that of the telescope, in the measure of the sqrt of the ratio
;	(telFWHM^2+wtFWHM^2)/telFWHM^2, so the effective gain was depressed in that
;	ratio. Since we divided the Tant scale by 8.6 (11, bm 0), and the effective
;	gain was lower than that by the above mentioned dilution factor, we must
;	multiply the flux scale by that factor.
;		

gain_dilution=1.+w_fwhm^2/(3.3*3.8)
grid_map=grid_map*gain_dilution/weight_map
cont_map_final=cont_map*gain_dilution/cont_weight_map
indx=where(finite(grid_map) eq 0,ncount)
print,ncount,' spectral values in grid map are NaN;'
print,       ' if weight_map=0, map is set to 0'
print,N_nodata,' grid points have no data nearby'
for ip=0,1 do begin
  for ii=0,NX-1 do begin
    for jj=0,NY-1 do begin
      ind=where(finite(grid_map[*,ip,ii,jj]) eq 0,ncount)
      if (ncount gt 0) then grid_map[ind,ip,ii,jj]=0.
      if (ncount gt 0) then cont_map[ip,ii,jj]=0    ;---> Added by B. Kent
    endfor
  endfor
endfor

; Apply ZA Correction. Assume Dec yields ZA, as most data taken at transit.
; For those drifts taken near Dec=18, for which Dec doesnt' yield ZA since
; data not taken at transit, we'll assume that data were taken at ZA<14deg,
; so that ZAC=1. rg30aug08

for jjj=0,NY-1 do begin
  decl_deg=Decmin+float(jjj)*dgdecmin/60.
  ZAng=abs(decl_deg-18.3)
  ZAC = 1.-(0.26/9.0)*(ZAng-14.)  ; using linear fit to PP's posted data
  if ZAC gt 1. then ZAC=1.
  grid_map(*,*,*,jjj)=grid_map(*,*,*,jjj)/ZAC
  cont_map(*,*,jjj)  =cont_map_final(*,*,jjj)/ZAC
endfor


map_projection='orthogonal'
wf_type='Gaussian'
baseline={nbase:intarr(2,NY), $
          coeffs:dblarr(2,NX,NY,10), $
          nreg:lonarr(2,NY,40,4), $
          rms:fltarr(2,NX,NY)}

calib_facs=dblarr(2,8,5)+1D
grms=stddev(grid_map)

  res=min(abs(velarr-vlow[isec]),chindx)
  ichstop[isec] =chindx
  ichstart[isec]=chindx-(nchcube-1)
  czmin=vlow[isec]
  varr=velarr[ichstart[isec]:ichstop[isec]]

  delvarx,dred,cont_map,mask,mc,cont_bg,cont_pt_wrk,indx

  grid={name:gname, $
      RAmin:ramin, Decmin:decmin, Epoch:epoch, $
      DeltaRA:dgrasec, DeltaDec:dgdecmin, $
      NX:NX, NY:NY, $
      map_projection:map_projection, $
      czmin:czmin, $
      NZ:1024, $
      velarr:varr, $
      wf_type:wf_type, $
      wf_fwhm:w_fwhm, $
      han:hansmooth, $
      medsubtract:medsubtract, $
      baseline:baseline, $
      calib_facs:calib_facs, $
      grms:grms, $
      date:systime(0), $
      who:who, $
      pos:tmp_pos, $
      drift_list:drift_list, $
      grid_makeup:grid_makeup, $
      d:grid_map, $
      w:weight_map, $
      cont:cont_map_final, $
      cw:cont_weight_map} 

  save,grid,file='grid_'+qual[isec]+'.sav'
  t40=systime(1)
  print,isec,t40-t30,' seconds runtime since starting to read data'

  delvarx,grid,grid_map,weight_map

endfor  ; this is the end of the isec loop which started at the beginning of Part 3!!


t_end=systime(1)
print,t_end-t00,' seconds, total run time'

end			; End of procedure
	
