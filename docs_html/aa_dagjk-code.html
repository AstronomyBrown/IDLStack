<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Apr 18 11:35:15 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>aa_dagjk.pro (Documentation for IDLstack)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles - edit header colors here*/
      div.header { padding: 2em 2em 0 2em; background: #04a53c; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #f44030; margin: 0; padding: 0; border-bottom: 1px #8e8d8d dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="aa_dagjk.pro (Documentation for IDLstack)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>

<span class="comments">;+</span>
<span class="comments">; </span>
<span class="comments">; The purpose of aa_dagjk is to estimate errors on stacked quantity using a modified </span>
<span class="comments">; delete-a-group jknife technique, a statistical estimate of the standard deviation </span>
<span class="comments">; that incorporates both the variance of the estimator and its bias.</span>
<span class="comments">;</span>
<span class="comments">; See Eq.1 `Kott, 2001 &lt;http://www.jos.nu/articles/abstract.asp?article=174521>`.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; When employed using random rejection, there are no theoretical advantages to DAGJK over the traditional</span>
<span class="comments">; ‘leave one out’ jackknife method. The main motivation for its use is that the grouping of</span>
<span class="comments">; data allows for significant gains in computational efficiency when applied to large samples</span>
<span class="comments">; while maintaining precision in the (nearly) unbiased confidence interval of the population</span>
<span class="comments">; parameter.</span>
<span class="comments">;</span>
<span class="comments">; This method ranks each spectra by a selected property (randomly, NUV-r, stellar mass), </span>
<span class="comments">; it then calculates the gas fraction iteratively, while </span>
<span class="comments">; discarding, in turn, a separate random subset of galaxies from the sample.</span>
<span class="comments">;</span>
<span class="comments">; e.g. for 100 galaxies in original stack and 20% resampling,</span>
<span class="comments">; aa_dagjk will remove 0-19,20-39,40-59,60-79, 80-100</span>
<span class="comments">;</span>
<span class="comments">; The resulting distribution of the stacked flux/mass/gas fractions is saved in the .sav structure.\</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;    Toby Brown</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;    Written by Toby Brown (April 2017). Based upon routines written by Silvia Fabello (April 2009).</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    aa_dagjk is a main level procedure included in aa_dagjk.pro::</span>
<span class="comments">;</span>
<span class="comments">;       IDL> aa_dagjk, 'path/to/aa_measure_output', 'path/to/file.cfg'</span>
<span class="comments">;</span>
<span class="comments">;    Iteratively stacks galaxies indexed by aa_stack, discarding 20% per iteration. Reduction and spectral measurements</span>
<span class="comments">;   are automatic.</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; Shift spectra in Fourier space by taking first the FFT and then the inverse FFT in order</span>
<span class="comments">; to centre the spectrum on the HI rest freq and account for the fact that increments in frequency</span>
<span class="comments">; do not correspond to equal increments in radial velocity.</span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;-</span>
<a id="freqshift:source"></a>pro freqshift,dx,spec_in,spec_out
  i=dcomplex(0,1) <span class="comments">; dcomple(A,B) returns A the real parts and B the imaginary parts of complex array i</span>
  ddx=dx*(-1.)                 
  n=n_elements(spec_in)  <span class="comments">;  returns the number of elements contained in spec_in</span>
  <span class="comments">;;create array of indices</span>
  indarr=dindgen(n)
  indarr[(n/2+1):n-1]=(-1)*reverse(dindgen(n/2-1))-1 
  <span class="comments">;;calculate fourier transform of shifted spectrum</span>
  ffts=fft(spec_in)*exp(2.0*!pi*i*ddx*indarr/double(n))
  <span class="comments">;;do the inverse transform to get back the shifted spectrum</span>
  spec_out=(fft(ffts,/INVERSE))
  spec_out=real_part(spec_out)
end

<span class="comments">;+</span>
<span class="comments">; Create progress bar </span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;-</span>
<a id="progbar:source"></a>pro progbar, percent, length=length
  length = (keyword_set(length))?length:40
  per = percent/100.0
  
  less = (floor(per*length)     eq 0)? '' : replicate('+', floor(per * length))
  grea = (ceil ((1-per)*length) eq 0)? '' : replicate('-', ceil( (1-per)*length ))
  bar = strmid(strjoin([less,grea]),0,length)
  
  print, format='(%"' + bar + ' [' + strtrim(long(per*100.0),2) + '\%]\r",$)'
end


<span class="comments">;+</span>
<span class="comments">; Store mouse click to set channel mask for baseline measurement</span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;-</span>
<a id="f_bmask:source"></a>pro f_bmask,bmask,nchn
  repeat begin
    print, 'Left click LEFT end of baseline box, right click to exit...'
    cp, x=x, y=y
    xpos1=round(x)
    if (xpos1 lt 0.) then xpos1 = 0.
    wait, 0.5
    if (!mouse.button eq 4) then goto, get_out
    print, 'Left click RIGHT edge of baseline box...'
    cp, x=x, y=y
    xpos2=round(x)
    if (xpos2 gt nchn-1) then xpos2=nchn-1
    wait, 0.5
    bmask[xpos1:xpos2]=1
  endrep until (!mouse.button eq 4)
  get_out:
end

<span class="comments">;+</span>
<span class="comments">; Lower order polynomial baseline fitting.</span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;-</span>
<a id="b_fit:source"></a>pro b_fit,bmask,nchn,norder,CDFchoice,ansb
    IF (CDFchoice EQ 'Y') AND (ansb EQ 'y') THEN BEGIN
        print,'Choosing 2nd order polynomial'
        norder = 2
    ENDIF ELSE BEGIN  
        get_order:
        print,'Enter poly order:'
        read_norder:
        read, norder
    ENDELSE
    if (norder gt 11) then begin
    print,'Fit order =',norder,' is a bit extreme; enter value &lt;12'
    goto, read_norder
  endif
end

<span class="comments">;+</span>
<span class="comments">; Store mouse clicks to set mask for rms measurement</span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;</span>
<span class="comments">; :Obsolete:</span>
<span class="comments">;-</span>
<a id="rms_mask:source"></a>pro rms_mask,mask,nchn
 repeat begin
     print, 'Left click LEFT end of rms box, right click to exit...'
     cp, x=x, y=y
     xpos1=round(x)
     if (xpos1 lt 0.) then xpos1 = 0.
     wait, 0.5
     if (!mouse.button eq 4) then goto, endloop
     print, 'Left click RIGHT edge of rms box...'
     cp, x=x, y=y
     xpos2=round(x)
     if (xpos2 gt nchn-1) then xpos2=nchn-1
     wait, 0.5
     mask[xpos1:xpos2]=1
 endrep until (!mouse.button eq 4)
endloop:
end

<span class="comments">;+</span>
<span class="comments">; :Params:</span>
<span class="comments">;    stackingdir : in, required, type=string</span>
<span class="comments">;                of the output directory of aa_measure.pro</span>
<span class="comments">;</span>
<span class="comments">;    cfgfile : in, required, type=string</span>
<span class="comments">;                Configuration file containing path to sample catalogue, options for stacking routine,</span>
<span class="comments">;                bin edges (see 'inputexample.cfg').</span>
<span class="comments">;</span>
<span class="comments">; :Description:     </span>
<span class="comments">;   Procedure</span>
<span class="comments">;   ---------</span>
<span class="comments">;</span>
<span class="comments">;       1. Restore stacked structure.</span>
<span class="comments">;</span>
<span class="comments">;       2. Rank galaxies by NUV-r, mu_star, M_star, C-index or Random (default NUV-r), and select 20% of the targets.</span>
<span class="comments">;</span>
<span class="comments">;       3. Stack following 'aa_stack.pro'.</span>
<span class="comments">;</span>
<span class="comments">;       4. Save a structure for each of the stacking repetition.</span>
<span class="comments">;</span>
<span class="comments">;       5. Measure the signal in the stacked spectrum, using the</span>
<span class="comments">;        reduction parameters from 'aa_measure.pro'</span>
<span class="comments">;</span>
<span class="comments">;       6. Update and modify the corresponding stack field with the values</span>
<span class="comments">;        measured. Which quantity is stacked, and if a correction for</span>
<span class="comments">;        confusion has to be applied is read from the structure (set</span>
<span class="comments">;        during 'aa_stack.pro').</span>
<span class="comments">; </span>
<span class="comments">;</span>
<span class="comments">;   Outputs</span>
<span class="comments">;   -------</span>
<span class="comments">;    'output/output_bin_no.sav' -  Modified structure containing the stack,</span>
<span class="comments">;                                    now with DAG jackknife fluxes/HI masses/gas fractions</span>
<span class="comments">;</span>
<span class="comments">;        jknife_flx,jknife_mhi,jknife_gf  - 5 independent Jacknife measures of stacked flux,</span>
<span class="comments">;                                            HI mass or gas fraction.</span>
<span class="comments">;</span>
<span class="comments">;       </span>
<span class="comments">; :Uses: </span>
<span class="comments">;    f_bmask, b_fit, progbar, freqshift</span>
<span class="comments">;       </span>
<span class="comments">; :Bugs:</span>
<span class="comments">;  It is possible for aa_dagjk program can handle multiple stacking directories, however to enable </span>
<span class="comments">;  this functionality the following lines::</span>
<span class="comments">;       </span>
<span class="comments">;       pro aa_dagjk, stackingdir</span>
<span class="comments">;       folders = [stackingdir]</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;  must be replaced with::</span>
<span class="comments">;</span>
<span class="comments">;       pro aa_dagjk, dir1, dir2, ..., dirN</span>
<span class="comments">;       folders = [dir1, dir2, ..., dirN]</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; :Categories: </span>
<span class="comments">;    Error analysis, ALFALFA software</span>
<span class="comments">;</span>
<span class="comments">;  </span>
<span class="comments">;-</span>
<a id="aa_dagjk:source"></a>pro aa_dagjk, stackingdir, cfgfile
folders = [stackingdir]

paramf = gm_read_textstructure(cfgfile)

!EXCEPT=2
<span class="comments">; Constants used</span>
lightsp=299792.458D           <span class="comments">;km/s</span>
restfrq=double(paramf.restfrq)    <span class="comments">; HI rest freq [MHz]</span>
deltaf=double(paramf.deltaf)    <span class="comments">; ALFALFA channel width [MHz/chn]</span>
nchn=double(paramf.nchn)  <span class="comments">; no. ALFALFA channels</span>

<span class="comments">;;Define final frequency array: 1024 chn, 1420MHz (v_0=V_syst) in chn 511.</span>
frqarr=restfrq+(findgen(nchn)-511)*deltaf <span class="comments">;frequency array</span>

<span class="comments">; Inputs</span>
path=paramf.path <span class="comments">; source path</span>
sampledir=paramf.sampledir <span class="comments">; database path</span>
listname=paramf.listname <span class="comments">; database name</span>

samplef = sampledir+listname


data_tab_tot=mrdfits(samplef,1)
z_tot = data_tab_tot.z
mass_tot=data_tab_tot.lgMst_median
ID_tot=data_tab_tot.ID


FOR fold=0,N_ELEMENTS(folders)-1 do begin
    
    output = folders[fold]
    spawn,'mkdir '+output+'/resample/'
    PRINT, ''
    xbin_tot = 5
    ybin_tot = 5
    <span class="comments">; read, bin_tot, prompt='How many structures do you want to RESTORE? (i.e. no. of bins) '</span>
    j_pc = 20 <span class="comments">; set discard fraction to 20%</span>


    FOR i=0,xbin_tot-1 do BEGIN
        
        xbin_no = STRCOMPRESS((i + 1), /remove_all)
        <span class="comments">; print, 'test', xbin_no</span>

        FOR j=0,ybin_tot-1 do BEGIN

            ybin_no = STRCOMPRESS((j + 1), /remove_all)
            PRINT, ''
            PRINT, 'Beginning bin number ' +xbin_no+'-'+ybin_no
            PRINT, ''
            <span class="comments">; Establish error handler. When errors occur, the index of the</span>
            <span class="comments">; error is returned in the variable Error_status:</span>
            CATCH, Error_status
            

            <span class="comments">;This statement begins the error handler:</span>
            IF Error_status NE 0 THEN BEGIN
                PRINT, 'Error index: ', Error_status
                PRINT, 'Error message: ', !ERROR_STATE.MSG
                <span class="comments">; Handle the error by extending A:</span>
                CATCH, /CANCEL
                goto, nogalaxies
            ENDIF
            
            <span class="comments">;;Restore reduction and stacking info from main file</span>
            PRINT, 'restoring... '+output+'/'+output+'_bin_'+xbin_no+'-'+ybin_no+'.sav'
            PRINT, ''
            file= output+'/'+output+'_bin_'+xbin_no+'-'+ybin_no+'.sav'
            RESTORE,file

            index=stack.hd.index
            IF stack.gf.totgf EQ 0 THEN BEGIN
                IF stack.MHI.totMHI EQ 0 THEN BEGIN
                    PRINT, ''
                    PRINT, 'No gas fraction. Run aa_measure.pro!'
                    PRINT, ''
                    goto, EXITDAG
                ENDIF
            ENDIF

            IF stack.detflag EQ 0 THEN BEGIN
                PRINT, ''
                PRINT, 'Non-detection, skipping Jackknife routine.'
                PRINT, ''
                goto, nogalaxies
            ENDIF
            
            <span class="comments">; IDs of galaxies used in central stack.</span>
            ID = stack.ID
           
            ndata = N_ELEMENTS(ID)
            PRINT, 'There are' + STRCOMPRESS(ndata) + ' galaxies in bin ' + xbin_no+'-'+ybin_no

            
            <span class="comments">; print, MIN(mu_star), MAX(mu_star), N_ELEMENTS(mu_star)</span>
            srcname='ID_'+STRCOMPRESS(ID, /remove_all)+'.src'
            data_file=path+srcname

            smo= stack.red.smooth
            bmask=stack.red.bmask
            norder=stack.red.bord
            ch1=stack.red.edge[0]
            ch2=stack.red.edge[1]
            chn1=stack.red.edge_err[0]
            chn2=stack.red.edge_err[1]
            xarr=findgen(nchn)
            velarr=lightsp*(Restfrq/(Restfrq+deltaf*(511-xarr))-1)
            indb=where(bmask EQ 1)
            nusedall=N_ELEMENTS(ID) -1 <span class="comments">;stack.nused[0]</span>
            whatstack=stack.hd.input[2]

            <span class="comments">; percentage to resample</span>
            j_step = FIX((ndata-1)*(j_pc/100.))
            rep = ndata/j_step
            cnt = 0 <span class="comments">; counter for the jknife reps</span>

            PRINT,''
            PRINT, 'Randomised resample with' + STRCOMPRESS(j_pc) + '% discarded.' 
            PRINT,''

            <span class="comments">;;------------- Jackknife: resample at given percentage.</span>
            <span class="comments">;;</span>
            jknife_flx=FLTARR(rep)
            jknife_mhi=FLTARR(rep)
            jknife_gf=FLTARR(rep) 
            
            <span class="comments">;-------------------PLOT NUV-r HIST --------------------------        </span>
            <span class="comments">;cgPS_open, plotdir + 'NUV-r_bin'+xbin_no+'_jk'+STRCOMPRESS(j_pc, /remove_all)+$</span>
            <span class="comments">;    '.pdf',$  ;'_N' + STRCOMPRESS(cnt+1, /remove_all) + </span>
           <span class="comments">; </span>
            <span class="comments">;XSIZE = 11.4, XOFFSET = 0., YOFFSET = 0., YSIZE = 8.692, /landscape</span>
            <span class="comments">;!P.CHARSIZE = 2</span>
            <span class="comments">;!P.CHARTHICK = 1</span>
            <span class="comments">;!P.FONT =0</span>
            <span class="comments">;!P.THICK  = 10</span>
            <span class="comments">;!X.THICK = 3</span>
            <span class="comments">;!Y.THICK = 3</span>
            CATCH, /CANCEL
            FOR jknife=0L,ndata-1,j_step DO BEGIN      <span class="comments">; Jackknife repetitions </span>

                pc=floor(100*jknife/(ndata))
                <span class="comments">;print, pc</span>
                progbar, pc
                
                stack_specA=FLTARR(nchn)
                stack_specB=FLTARR(nchn)
                rms_A_vec=FLTARR(nusedall)
                rms_B_vec=FLTARR(nusedall)
                rmstotA=0.
                rmstotB=0.
                indx=FLTARR(nusedall)
                z_vec=FLTARR(nusedall)
                mst_vec=FLTARR(nusedall)
                sconfone_up=FLTARR(nusedall)
                sconfone=FLTARR(nusedall)
                <span class="comments">;; resampling of galaxies included in the stack</span>
                idx=INDGEN(ndata)
                
                <span class="comments">; print, jknife, j_step, ndata</span>
                IF (jknife+j_step ge ndata) THEN goto, stopjk
                
                PRINT, ''
                PRINT, 'Resample Number:' + STRCOMPRESS(cnt+1)
                PRINT, 'Galaxy spectra' + STRCOMPRESS(jknife+1) + ' -' + $
                        STRCOMPRESS(jknife+j_step) +' are being excluded.'
                
                all=[idx[0:jknife],idx[jknife+j_step:-1]]
                ii=index[all]              <span class="comments">;which position in the all initial sample</span>
                nconf=0
                nnk = 0

                
                FOR k=0,n_elements(all)-1 DO BEGIN  

                    restore, path+'ID_' + STRCOMPRESS(ID[all[k]], /remove_all)+'.src'

                    
                    ra=src.hd.input[0]
                    dec=src.hd.input[1]

                    z= z_tot[WHERE(ID_tot EQ ID[all[k]], /NULL)]
                    z = DOUBLE(z[0])
                    mstar= mass_tot[WHERE(ID_tot EQ ID[all[k]], /NULL)]
                    mstar = DOUBLE(mstar[0])

                    <span class="comments">; z = DOUBLE(zspecarr[0])</span>
                    <span class="comments">; z = z_arr[all[k]]</span>
                    <span class="comments">; z = z[0]</span>

                    wopt=src.hd.input[3]/2.       <span class="comments">;half w_opt if available from TF, or 300/2. km/s</span>
                    <span class="comments">; mstar = mass[all[k]]</span>
                    rms_A=src.rms[0]
                    rms_B=src.rms[1]

         
                    <span class="comments">;; Assign pol A and B flux</span>
                    sourcefrq = src.frqarr <span class="comments">; Frequency</span>
                    specA_in = src.specpol.YARRA
                    specB_in = src.specpol.YARRB
                    weightA = src.weight.wspeca
                    weightB = src.weight.wspecb

                    <span class="comments">; plot, (specA_in+specB_in)/2, charsize=2</span>

                    <span class="comments">;;; Set spec to 0 where weight &lt; 0</span>
                    w = WHERE((weightA lt 0.1) or (weightB lt 0.1))
                    specA_in[w] =  0
                    specB_in[w] =  0

                    CASE whatstack of 
                        1: BEGIN
                            specA=specA_in <span class="comments">;flux</span>
                            specB=specB_in
                        END
                        2: BEGIN             <span class="comments">;M_HI</span>
                            specA=DOUBLE(specA_in*lumdist(z,/silent)^2/(1.+z))      
                            specB=DOUBLE(specB_in*lumdist(z,/silent)^2/(1.+z))         
                        END
                        3: BEGIN             <span class="comments">;M_HI/M_*</span>
                            specA=DOUBLE(specA_in*lumdist(z,/silent)^2/(1.+z)/10.d0^mstar)
                            specB=DOUBLE(specB_in*lumdist(z,/silent)^2/(1.+z)/10.d0^mstar)
                        END
                    ENDCASE

                        <span class="comments">; IF k EQ 1 THEN stop</span>

                    frq_c=(restfrq/(z + 1.))
                    d_ch=floor((src.frqarr[511]-frq_c)/(deltaf))

                    <span class="comments">; print, spec_outA</span>
                    freqshift,d_ch,specA,spec_outA
                    freqshift,d_ch,specB,spec_outB

                    stack_specA=stack_specA+spec_outA/(rms_A^2)
                    stack_specB=stack_specB+spec_outB/(rms_B^2)

                    rms_A_vec[k]=rms_A
                    rms_B_vec[k]=rms_B
                    rmstotA=rmstotA+1/(rms_A^2)
                    rmstotB=rmstotB+1/(rms_B^2)
                    z_vec[k]=z
                    mst_vec[k]=mstar
                    indx[k]=k
                
                    nnk=nnk+1
                ENDFOR
             
             
                z_avg=mean(z_vec[0:k-1])
                mst_avg=mean(10^mst_vec[0:k-1])
                indexk=indx[0:k-1]
                rmsav=total(rms_A_vec[0:k-1])/k
                rmsbv=total(rms_B_vec[0:k-1])/k

                stack_specA=stack_specA/rmstotA
                stack_specB=stack_specB/rmstotB

                <span class="comments">; print,'rms = ', total(rms_A_vec[0:k-1])/k</span>
                
                stack_specA_flx=FLTARR(nchn)
                stack_specB_flx=FLTARR(nchn)
                stack_specA_mhi=FLTARR(nchn)
                stack_specB_mhi=FLTARR(nchn)
                stack_specA_gf=FLTARR(nchn)
                stack_specB_gf=FLTARR(nchn)
                
                
                CASE whatstack of 
                    1: BEGIN                <span class="comments">;Flux</span>
                       stack_specA_flx=stack_specA
                       stack_specB_flx=stack_specB
                    END
                    2: BEGIN                <span class="comments">;M_HI</span>
                       stack_specA_mhi=stack_specA
                       stack_specB_mhi=stack_specB
                    END
                    3: BEGIN                <span class="comments">;M_HI/M_*</span>
                       stack_specA_gf=stack_specA
                       stack_specB_gf=stack_specB
                    END
                ENDCASE

                
                sname=output+'/resample/'+output+'_'+xbin_no+'-'+ybin_no+'_rep-'+strtrim(rep+1,2) +'.sav'
                
                hd={input:[z_avg,mst_avg,whatstack],file:output,index:indexk}
                red={edge:[0,0],edge_err:[0,0],bmask:intarr(nchn),bord:0,smooth:0} <span class="comments">;reduction parameter</span>
                specA={flx:stack_specA_flx,mhi:stack_specA_mhi,gf:stack_specA_gf}  
                specB={flx:stack_specB_flx,mhi:stack_specB_mhi,gf:stack_specB_gf} 
                spec={flx:FLTARR(nchn),mhi:FLTARR(nchn),gf:FLTARR(nchn)} 
                S={totS:0.,totSerr:0.,totSerr_sys:0.,totSerr_tot:0.}
                MHI={totMHI:0.,totMHIerr:0.,totMHIerr_sys:0.,totMHIerr_tot:0.}
                GF={totGF:0.,totGFerr:0.,totGFerr_sys:0.,totGFerr_tot:0.}
                sn={flx:FLTARR(3),mhi:FLTARR(3),gf:FLTARR(3)}
                
                
                stack ={hd:hd, $           <span class="comments">;z mean,mst mean, 0,0,0</span>
                    nused:nnk, $
                    frqarr:frqarr, $
                    specA:specA, $
                    specB:specB, $
                    spec:spec, $              <span class="comments">;;to be filled later</span>
                    red:red,$
                    rms:[rmsav,rmsbv,0.,0.],$
                    rms_mhi:[0.,0.],$
                    rms_gf:[0.,0.],$
                    S:S,$
                    MHI:MHI,$
                    GF:GF,$
                    sn:sn,$
                    c_factor:[-99,-99]}
                
                SAVE,stack,file=sname
        <span class="comments">;;------------------------------END STACKING, EVALUATE</span>
                <span class="comments">;;RESTORE closed structure</span>
                RESTORE,sname
                nused=stack.nused[0]
                
                CASE whatstack of          <span class="comments">;which quantity has been stacked</span>
                    1: BEGIN                <span class="comments">;flux</span>
                    speca=DOUBLE(stack.speca.flx)
                    specb=DOUBLE(stack.specb.flx)
                    END
                    2: BEGIN                <span class="comments">;M_HI</span>
                    speca=DOUBLE(stack.speca.mhi)
                    specb=DOUBLE(stack.specb.mhi)
                    END
                    3: BEGIN                <span class="comments">;M_HI/M_*</span>
                    speca=DOUBLE(stack.speca.gf)
                    specb=DOUBLE(stack.specb.gf)
                    END
                ENDCASE
                
                spec=(specA+specB)/2.
                specnew=hans(3,spec)
                specnew1=smooth(specnew,smo)
                specnew= specnew1  
                bcoef=poly_fit(xarr[indb],specnew[indb],norder)
                yfit=poly(xarr,bcoef)
                spec=specnew-yfit
                <span class="comments">; plot, spec, charsize=2</span>
                rms= STDDEV(spec[indb])

                w=abs(velarr[ch1]-velarr[ch2])
                vch=0.5*(ch1+ch2)
                dv=abs(velarr[vch]-velarr[vch+1]) <span class="comments">;channel width in km/s</span>
                dv_smo=dv*SQRT(smo*smo+2.0*2.0)   <span class="comments">; vel. res. of Hanning + boxcar smoothed spectrum</span>
                
                totS=DOUBLE(total(spec[ch1:ch2])*dv)

                <span class="comments">; print, ''</span>
                <span class="comments">; print, 'channels 1,2 ', ch1,ch2</span>
                <span class="comments">; print, 'total spec ', total(spec[ch1:ch2])</span>
                <span class="comments">; print, ''</span>
                totSerr=DOUBLE(rms*dv*SQRT(ch2-ch1))
                totSerr_S05=DOUBLE(2.*rms*SQRT(1.4*w*dv_smo)) <span class="comments">; CU HI archive definition (Springob+ 2005, eqn. 2)</span>
                peakS=DOUBLE(max(spec[ch1:ch2]))
                totSerr_sys=DOUBLE(0.)
                totSerr_tot=DOUBLE(0.)
                <span class="comments">; totSerr_sys= abs(totS- total(spec[chn1:chn2])*dv)/2. ; mJy km/s</span>
                <span class="comments">; totSerr_tot=SQRT(totSerr_S05^2+totSerr_sys^2)</span>
                
                smofac=W/(2.*dv_smo)       <span class="comments">; dv_smo= 10 km/s for ALFALFA, after han</span>
                IF (W gt 400.) THEN  smofac=400./(2.*dv_smo)
                stn=FLTARR(4)
                stn[0]=(totS/W)*SQRT(smofac)/rms <span class="comments">; ALFALFA definition, width just width :)</span>
                stn[1]=peakS/rms
                        
                CASE whatstack of          <span class="comments">;which quantity has been stacked</span>
                    1: BEGIN                <span class="comments">;flux</span>
                        stack.S.totS=totS
                        stack.S.totSerr_sys=totSerr_sys
                        stack.S.totSerr=totSerr_tot 
                        stack.spec.flx=spec
                        stack.rms[2]=rms
                        stack.rms[3]=rms/SQRT(150./dv_smo)
                        stack.sn.flx=stn[0:1]  
                    END
                    2: BEGIN                <span class="comments">;mhi</span>
                        <span class="comments">; help, stack</span>
                        stack.MHI.totMHI=DOUBLE(2.356*10^4*10*totS/1000.) 
                        stack.MHI.totMHIerr=DOUBLE(2.356*10^4*10*totSerr_tot/1000.)
                        stack.spec.mhi=spec
                        stack.rms_mhi[0]=rms
                        stack.rms_mhi[1]=rms/SQRT(150./dv_smo)
                        stack.sn.mhi=stn[0:1]  
                    END
                    3: BEGIN                <span class="comments">;mhi/m*</span>
                        <span class="comments">; print,'TotS', totS</span>
                        stack.GF.totGF=DOUBLE(2.356*10^4*10*totS/1000.) 
                        <span class="comments">; print,'M_HI/M* ', DOUBLE(2.356*10^4*10*totS/1000.)</span>
                        stack.GF.totGFerr=DOUBLE(2.356*10^4*10*totSerr_tot/1000.)
                        stack.spec.gf=spec
                        stack.rms_gf[0]=rms
                        stack.rms_gf[1]=rms/SQRT(150./dv_smo)
                        stack.sn.gf=stn[0:1]
                    END
                ENDCASE
                
                <span class="comments">;----------------------------------------</span>
                <span class="comments">; Plot stack spec of jackknife.</span>
                
                <span class="comments">; plotdir = '/Users/thbrown/AA_project/TOBY_STACKING/TSTACK/plots/error_testing/jknife/specs/'</span>
                <span class="comments">; cgPS_open, plotdir +$</span>
                <span class="comments">;    'jk'+STRCOMPRESS(j_pc, /remove_all)+$</span>
                <span class="comments">;        '_bin'+xbin_no+$</span>
                <span class="comments">;            '_rep'+STRCOMPRESS(cnt+1, /remove_all)+$</span>
                <span class="comments">;                '.pdf',$</span>


                <span class="comments">; XSIZE = 11.4, XOFFSET = 0., YOFFSET = 0., YSIZE = 8.692, /landscape</span>
                <span class="comments">; !P.CHARSIZE = 2</span>
                <span class="comments">; !P.CHARTHICK = 1</span>
                <span class="comments">; !P.FONT =0</span>
                <span class="comments">; !P.THICK  = 10</span>
                <span class="comments">; !X.THICK = 3</span>
                <span class="comments">; !Y.THICK = 3</span>
                <span class="comments">; CASE whatstack of    ;which quantity has been stacked</span>
                <span class="comments">;   1: yt=textoidl('mJy\cdot (km/s)^2') </span>
                <span class="comments">;   2: yt=textoidl('mJy\cdot (km/s)^2 Mpc^2') </span>
                <span class="comments">;   3: yt=textoidl('mJy (km/s)^2 Mpc^2 / Msol') </span>
                <span class="comments">; ENDCASE        </span>
                
                <span class="comments">; PLOT, velarr,  spec,CHARSIZE = 2,$</span>
                <span class="comments">;    TITLE='Spectra for bin ='+xbin_no+', rep ='+STRCOMPRESS(cnt+1, /remove_all), $</span>
                <span class="comments">;        YRANGE=[MIN(spec), MAX(spec)],$</span>
                <span class="comments">;            XRANGE=[MIN(velarr), MAX(velarr)],$ </span>
                <span class="comments">;            CHARTHICK = 1,$</span>
                <span class="comments">;                XTITLE = 'Velocity [km/s]',$</span>
                <span class="comments">;                    YTITLE = yt</span>
              
                <span class="comments">; OPLOT,velarr, fltarr(N_ELEMENTS(velarr)),linestyle=1</span>
               
                <span class="comments">; vline,velarr[ch1], linestyle = 2, THICK  = 2</span>
                <span class="comments">; vline,velarr[ch2], linestyle = 2, THICK  = 2</span>

                <span class="comments">; cgPS_Close</span>
                
                <span class="comments">;----------------------------------------</span>
                
                stack.red.edge=[ch1,ch2]
                stack.red.edge_err=[chn1,chn2]
                stack.red.bmask=bmask
                stack.red.bord=norder
                stack.red.smooth=smo
             
                CASE whatstack of          <span class="comments">;which quantity (1.-(j_pc/100.)has been stacked</span>
                    1: jknife_flx[cnt]=totS
                    2: jknife_mhi[cnt]=double(2.356*10^4*10*totS/1000.)
                    3: jknife_gf[cnt]=double(2.356*10^4*10*totS/1000.)
                ENDCASE
                skip:
                cnt = cnt+1 <span class="comments">; counter</span>
            ENDFOR
            stopjk:
            
            SAVE,stack,file=sname
            <span class="comments">;;Save results in original structure </span>
            RESTORE,output+'/'+output+'_bin_'+xbin_no+'-'+ybin_no+'.sav'<span class="comments">;, /RELAXED_STRUCTURE_ASSIGNMENT </span>
            
            stack = MOD_STRUCT(stack,'resamp_flx', FLTARR(rep)) <span class="comments">; Modify the existing structure to add input</span>
            stack = MOD_STRUCT(stack,'resamp_MHI', FLTARR(rep)) <span class="comments">; jackknifed flx, mhi or gf measurments                 </span>
            stack = MOD_STRUCT(stack,'resamp_GF', FLTARR(rep))
            
            PRINT, ''
            PRINT, ''
            PRINT, ''
            print,'Original M_HI/M* ', stack.gf.totgf
            PRINT, ''

            stack.resamp_flx=jknife_flx
            stack.resamp_MHI=jknife_mhi
            stack.resamp_GF=jknife_gf

            spath = output+'/'+output+'_bin_'+xbin_no+'-'+ybin_no+'.sav'
            SAVE,stack,file=spath
            
            PRINT,'resample errors saved to '+spath
            openu,lun,output+'/'+output+'_bin_'+xbin_no+'-'+ybin_no+'_LOG.dat',/get_lun,/append <span class="comments">; open the data file 4 update</span>
            PRINTF, lun,' '
            PRINTF, lun, '-------------------------------------------------'
            CASE stack.hd.input[2] of    <span class="comments">;which quantity has been stacked</span>
                1: PRINTF, lun,STDDEV(stack.resamp_GF),format="('jknife error +/- ',f6.2)"
                2: PRINTF, lun,STDDEV(stack.resamp_GF),format="('jknife error +/- ',f10.2)"
                3: PRINTF, lun,STDDEV(stack.resamp_GF),format="('jknife error +/- ',f5.3)"
            ENDCASE
            PRINTF, lun,floor(0.8*nusedall),format="('Evaluated over stacking of ',i4,' galaxies')"
            
            close,lun
            free_lun, lun
            nogalaxies:

        ENDFOR
    ENDFOR
ENDFOR
EXITDAG:
PRINT, ''
PRINT, 'ALL DONE!'
PRINT, ''

END
</code>
    </div>
  </body>
</html>