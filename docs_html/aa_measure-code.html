<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Apr 18 11:35:16 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>aa_measure.pro (Documentation for IDLstack)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles - edit header colors here*/
      div.header { padding: 2em 2em 0 2em; background: #04a53c; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #f44030; margin: 0; padding: 0; border-bottom: 1px #8e8d8d dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="aa_measure.pro (Documentation for IDLstack)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>

<span class="comments">;+</span>
<span class="comments">; The purpose of aa_measure is to reduce and measure stacked spectra produced </span>
<span class="comments">; by aa_stack. </span>
<span class="comments">;</span>
<span class="comments">; This procedure iteratively measures spectra for all bins (including 2D)</span>
<span class="comments">; contained in the specified directory.</span>
<span class="comments">; </span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;    Toby Brown</span>
<span class="comments">;</span>
<span class="comments">; :History:</span>
<span class="comments">;    Written by Toby Brown (April 2017). Based upon routines written by Silvia Fabello (April 2009).</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    aa_measure is a main level procedure included in aa_measure.pro::</span>
<span class="comments">;</span>
<span class="comments">;       IDL> aa_measure, 'path/to/aa_stack_output'</span>
<span class="comments">;</span>
<span class="comments">;    Iteratively restores and plots stacked spectra in 'aa_stack_output' directory to</span>
<span class="comments">;    screen, asks user for baseline fitting parameters and profile edges, saves output to </span>
<span class="comments">;    original aa_stack structures.</span>
<span class="comments">;</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; Store mouse click to set channel mask for baseline measurement</span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;-</span>
<a id="f_bmask:source"></a>pro f_bmask,bmask,nchn
  repeat begin
    print, 'Left click LEFT end of baseline box, right click to exit...'
    cp, x=x, y=y
    xpos1=round(x)
    if (xpos1 lt 0.) then xpos1 = 0.
    wait, 0.5
    if (!mouse.button eq 4) then goto, get_out
    print, 'Left click RIGHT edge of baseline box...'
    cp, x=x, y=y
    xpos2=round(x)
    if (xpos2 gt nchn-1) then xpos2=nchn-1
    wait, 0.5
    bmask[xpos1:xpos2]=1
  endrep until (!mouse.button eq 4)
  get_out:
end

<span class="comments">;+</span>
<span class="comments">; Lower order polynomial baseline fitting.</span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;-</span>
<a id="b_fit:source"></a>pro b_fit,bmask,nchn,norder,CDFchoice,ansb
    IF (CDFchoice EQ 'Y') AND (ansb EQ 'y') THEN BEGIN
        print,'Choosing 2nd order polynomial'
        norder = 2
    ENDIF ELSE BEGIN  
        get_order:
        print,'Enter poly order:'
        read_norder:
        read, norder
    ENDELSE
    if (norder gt 11) then begin
    print,'Fit order =',norder,' is a bit extreme; enter value &lt;12'
    goto, read_norder
  endif
end

<span class="comments">;+</span>
<span class="comments">; Store mouse clicks to set mask for rms measurement</span>
<span class="comments">;</span>
<span class="comments">; :Private:</span>
<span class="comments">;</span>
<span class="comments">; :Obsolete:</span>
<span class="comments">;-</span>
<a id="rms_mask:source"></a>pro rms_mask,mask,nchn
 repeat begin
     print, 'Left click LEFT end of rms box, right click to exit...'
     cp, x=x, y=y
     xpos1=round(x)
     if (xpos1 lt 0.) then xpos1 = 0.
     wait, 0.5
     if (!mouse.button eq 4) then goto, endloop
     print, 'Left click RIGHT edge of rms box...'
     cp, x=x, y=y
     xpos2=round(x)
     if (xpos2 gt nchn-1) then xpos2=nchn-1
     wait, 0.5
     mask[xpos1:xpos2]=1
 endrep until (!mouse.button eq 4)
endloop:
end

<span class="comments">;+</span>
<span class="comments">; :Params:</span>
<span class="comments">;    stackingdir : in, required, type=string</span>
<span class="comments">;                of the output directory of aa_stack.pro</span>
<span class="comments">;</span>
<span class="comments">; :Description:     </span>
<span class="comments">;   Procedure</span>
<span class="comments">;   ---------</span>
<span class="comments">;</span>
<span class="comments">;       1. Require user to specify if 2D bins were used in aa_stack.pro</span>
<span class="comments">;</span>
<span class="comments">;       2. Restore the main "stack" structure.</span>
<span class="comments">;</span>
<span class="comments">;       3. Smooth the spectrum: a default Hanning smoothing over 3 channels is applied</span>
<span class="comments">;           the user can then boxcar smooths over N channels.  </span>
<span class="comments">;</span>
<span class="comments">;       4. Subtract a baseline.</span>
<span class="comments">;</span>
<span class="comments">;       5. Flag the edges of the emission.</span>
<span class="comments">;</span>
<span class="comments">;       6. Evaluate the signal as integral inside the profile or</span>
<span class="comments">;           evaluate the signal of non-detections (300 km/s ms > 10^10Msol; 200km/s ms &lt;= 10^10Msol) using rms value</span>
<span class="comments">;</span>
<span class="comments">;       7. Save output back to original structure.</span>
<span class="comments">;</span>
<span class="comments">;       8. Repeat for other bins in output directory.</span>
<span class="comments">;</span>
<span class="comments">; </span>
<span class="comments">;</span>
<span class="comments">;   Outputs</span>
<span class="comments">;   -------</span>
<span class="comments">;    'stackingdir/stackingdir_bin_no.sav' - Modified stack structure with the following updated::</span>
<span class="comments">;</span>
<span class="comments">;        RED         - Reduction parameters i.e. profile edges, baseline masks</span>
<span class="comments">;</span>
<span class="comments">;        RMS         - Average rms of stacked spectrum</span>
<span class="comments">;</span>
<span class="comments">;        S, MHI,GF   - Total flux, HI mass, gas fractions</span>
<span class="comments">;</span>
<span class="comments">;        detflag     - Flag if stack is detection (1) or non-detections (0)</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;   'output_bin_no_LOG.dat' - additional information about reduction appended:    </span>
<span class="comments">;           Polynomial order of fitted baseline; smoothing; S/N [ALFALFA]; edges of signal; measured signal</span>
<span class="comments">;       </span>
<span class="comments">; :Uses: </span>
<span class="comments">;    f_bmask, b_fit</span>
<span class="comments">;       </span>
<span class="comments">; :Bugs:</span>
<span class="comments">;    </span>
<span class="comments">;</span>
<span class="comments">; :Categories: </span>
<span class="comments">;    Data analysis, ALFALFA software</span>
<span class="comments">;</span>
<span class="comments">;  </span>
<span class="comments">;-</span>
<a id="aa_measure:source"></a>pro aa_measure, stackingdir

!EXCEPT=2 
HIfreq=1420.405751786D
lightsp=299792.458D
deltaf=0.024414063

xbin_tot = 5
ybin_tot = 5
<span class="comments">; read, xbin_no, prompt='How many structures do you want to restore? (i.e. no. of bins) '</span>

CDFchoice = 'N'
CDFchoice_str = ['','Are you measuring flux in cumulative distribution function (CDF) bins?',$
                     '(Y/N)', '']
print, CDFchoice_str, FORMAT='(A)' 
read, CDFchoice ,prompt=''
CDFchoice = strmid(strupcase(CDFchoice),0,1)

for j=0,xbin_tot-1 do begin
    xbin_no = STRCOMPRESS((j + 1), /remove_all)
    for k=0,ybin_tot-1 do begin
    	
        ybin_no = STRCOMPRESS((k + 1), /remove_all)
        print, 'Beginning bin number ' +xbin_no+'-'+ybin_no

        <span class="comments">; Establish error handler. When errors occur, the index of the</span>
        <span class="comments">; error is returned in the variable Error_status:</span>
        CATCH, Error_status

        <span class="comments">;This statement begins the error handler:</span>
        IF Error_status NE 0 THEN BEGIN
            PRINT, 'Error index: ', Error_status
            PRINT, 'Error message: ', !ERROR_STATE.MSG
            <span class="comments">; Handle the error by extending A:</span>
            
            CATCH, /CANCEL
            goto, nogalaxies
        ENDIF

        IF CDFchoice EQ 'Y' THEN BEGIN
            logFile = stackingdir+'/'+stackingdir+'_bin_'+xbin_no+'-'+ybin_no+'_LOG.dat'
            file=stackingdir+'/'+stackingdir+'_bin_'+xbin_no+'-'+ybin_no+'.sav'
        ENDIF ELSE BEGIN  
            logFile = stackingdir+'/'+stackingdir+'_bin_'+xbin_no+'_LOG.dat'
            file=stackingdir+'/'+stackingdir+'_bin_'+xbin_no+'-'+ybin_no+'.sav'
        ENDELSE

        restore, file

        case stack.hd.input[2] of    <span class="comments">;which quantity has been stacked</span>
            1: begin                  <span class="comments">;flux</span>
                speca=double(stack.speca.flx)
                specb=double(stack.specb.flx)
            end
            2: begin               <span class="comments">;M_HI</span>
                speca=double(stack.speca.mhi)
                specb=double(stack.specb.mhi)
            end
            3: begin                  <span class="comments">;M_HI/M_*</span>
                speca=double(stack.speca.gf)
                specb=double(stack.specb.gf)
            end
        endcase

        nused=stack.nused[0]
        nchn=N_ELEMENTS(speca)
        xarr=findgen(nchn)
        <span class="comments">; The blue-shift equation for velocity is: vrad/c=(1 - f0/f)=z/(1+z)</span>
        velarr=lightsp*(HIfreq/(HIfreq+deltaf*(511-xarr))-1)
        bmask=intarr(nchn)
        maskA=intarr(nchn)
        maskB=intarr(nchn)
        basecoef=dblarr(12)
        hor
        ver
        window,xsize=900,ysize=600
        case stack.hd.input[2] of    <span class="comments">;which quantity has been stacked</span>
            1: yt=textoidl('mJy\cdot (km/s)^2')
            2: yt=textoidl('mJy\cdot (km/s)^2 Mpc^2') 
            3: yt=textoidl('mJy\cdot (km/s)^2 Mpc^2 / M_{sol}') 
        endcase
        <span class="comments">;;PO3A</span>
        !P.MULTI = [0, 1, 2]
        plot, speca,title='pol A',ytitle=yt,charsize = 3 ,yrange=[1.2*min(speca),1.2*max(speca)]
        oplot,[511,511],[1.2*min(speca),1.2*max(speca)], linestyle=2
        click= ' '
        <span class="comments">; read,click,prompt='Enter to continue...'</span>
        <span class="comments">;;POLB</span>
        <span class="comments">;;Change the vertical scale if necessary</span>
        hor
        ver
        plot,specb,title='pol B',ytitle=yt,charsize = 3 ,yrange=[1.2*min(specb),1.2*max(specb)]
        oplot,[511,511],[1.2*min(specb),1.2*max(specb)], linestyle=2
        <span class="comments">; read,click,prompt='Enter to continue...'</span>

        print,'--- Averaged spectrum ---'
        <span class="comments">;;;FINAL SPEC</span>
        hor
        ver
        spec=(specA+specB)/2.
        plot,spec,ytitle=yt,charsize = 3 ,yrange=[1.2*min(spec),1.2*max(spec)]
        oplot,[511,511],[1.2*min(spec),1.2*max(spec)], linestyle=2
        print,min(spec),max(spec)

        ysc='n'
        <span class="comments">;read, ysc, prompt='Rescale vertical axis? [y/N] '</span>
        print, ''
        if (ysc eq '') then ysc='n'
        ysc=strmid(strlowcase(ysc),0,1)

        if (ysc eq 'y') then begin
           doysc:
           a=0.
           b=0.
           read, a, b, prompt='Enter desired ymin and ymax (e.g.: 1,5): '
           ver, a, b
           plot,spec,ytitle=yt,charsize = 3
           oplot,[511,511],[a,b], linestyle=2
           ans='y'
           read,ans,prompt='OK? [Y/n]'
           if (ans eq '') then ans='y'
           ans=strmid(strlowcase(ans),0,1)
           if (ans eq 'n') then  goto,doysc
        endif else begin 
           a=1.2*min(spec)
           b=1.2*max(spec)
        endelse


        <span class="comments">;;----------------------------------------</span>
        <span class="comments">;; BOXCAR SMOOTHING</span>
        specnew=hans(3,spec)
        print,'Permormed an Hanning smoothing over 2 channels.'

        boxcarsm:
        !P.MULTI=0
        plot,specnew,ytitle=yt,charsize = 3
        oplot,[511,511],[a,b], linestyle=2
        smo=5
        print, "Boxcar smoothing. Enter # of channels to smooth by (odd number): "
        <span class="comments">;read, smo</span>
        specnew1=smooth(specnew,smo)
        hor
        ans=''
        plot,specnew1,ytitle=yt,charsize = 3
        oplot,[511,511],[a,b], linestyle=2
        ans='y'
        <span class="comments">;read,ans,prompt='OK? [Y/n]'</span>
        if (ans eq '') then ans='y'
        ans=strmid(strlowcase(ans),0,1)
        if (ans eq 'n') then  goto,boxcarsm
        specnew= specnew1

        <span class="comments">; BASELINE FITTING</span>
        print,''
        print, 'BASELINE FITTING'
        print,''
        f_bmask,bmask,nchn
        ansb='y'
        b_fit,bmask,nchn,norder,CDFchoice,ansb
        indb=where(bmask eq 1)
        fit_base:
        bcoef=poly_fit(xarr[indb],specnew[indb],norder)
        yfit=poly(xarr,bcoef)
        basecoef[0:norder]=bcoef
        oplot,yfit
        read,ansb,prompt='Baseline OK? [Y/n]'
        if (ansb eq '') then ansb='y'
        ansb=strmid(strlowcase(ansb),0,1)
        if (ansb eq 'n') then begin
            plot,specnew,ytitle=yt,charsize = 3
            oplot,[511,511],[a,b], linestyle=2
            oplot,fltarr(nchn),linestyle=1
            b_fit,bmask,nchn,norder,CDFchoice,ansb
            indb=where(bmask eq 1)
            goto,fit_base
        endif
        spec=specnew-yfit
        plot,spec ,ytitle=yt,charsize = 3 
        oplot,[511,511],[a,b], linestyle=2
        oplot,fltarr(nchn),linestyle=1

        rms= stddev(spec[indb])

        <span class="comments">;;----------------------------------------</span>
        <span class="comments">; Check if the stack is a non detection</span>
        <span class="comments">; Evaluate the signal of non-detection (300 km/s ms > 10^10Msol; 200km/s ms &lt;= 10^10Msol) using rms value</span>
        detflag='y'
        detflag_n=1
        IF (CDFchoice EQ 'Y') THEN BEGIN
            detflag = 'y'
        ENDIF ELSE BEGIN  
            read, detflag, prompt='Is the stack a detection? [Y/N] '
            print, ''
        ENDELSE
        if (detflag eq '') then detflag='y'
        detflag=strmid(strlowcase(detflag),0,1)

        IF (detflag eq 'n') then begin
            <span class="comments">; rms= stack.rms_gf[0]</span>
            totSerr_tot = 0
            TOTSERR_SYS = 0
            detflag_n=0
            <span class="comments">; MEASURE Signal upper limit</span>
            w=300. <span class="comments">;; set velocity width 300 km/s for ms > 10^10Msol; 200km/s for ms &lt;= 10^10Msol</span>
            mean_ms = stack.MEAN_BINP[0]
            IF (mean_ms le 10) then w = 200.
            vch=FIX(0.5*(N_ELEMENTS(velarr)))
            dv=abs(velarr[vch]-velarr[vch+1]) <span class="comments">;channel width in km/s</span>
            print, dv
            dv_smo=dv*sqrt(smo*smo+2.0*2.0)   <span class="comments">; vel. res. of Hanning + boxcar smoothed spectrum</span>
            totS=double(rms*w*smo)
            totSerr=double(rms*dv*sqrt(60))
            totSerr_S05=double(2.*rms*sqrt(1.4*w*dv_smo)) <span class="comments">; CU HI archive definition (Springob+ 2005, eqn. 2)</span>
            goto, exitmeasure
        ENDIF

        <span class="comments">;;MEASURE Signal</span>
        <span class="comments">;;zoom in spectrum first</span>
        plot,spec,ytitle=yt,charsize = 3  
        oplot,[511,511],[a,b], linestyle=2
        print,' '
        print,'Left click LEFT and RIGHT channel limits for plot'
        cp, x=x, y=y
        hor1=round(x)
        wait,0.5
        cp, x=x, y=y
        hor2=round(x)
        wait,0.5
        hor,hor1,hor2
        y_min=min(spec[hor1:hor2])
        y_max=max(spec[hor1:hor2])
        ver,y_min-0.2*(y_max-y_min),y_max+0.2*(y_max-y_min)

        <span class="comments">;;Flag channels corresponding to edges [ch1,ch2] and peaks [chp1,chp2] of profile</span>
        flagmsr:
        plot,spec,ytitle=yt,charsize = 3  
        oplot,[511,511],[a,b], linestyle=2
        oplot,fltarr(nchn), linestyle=2 <span class="comments">;y=0 dashed line</span>
        print,' '
        print,'Flag edges of spectral feature to be measured:'
        print, 'Left click LEFT edge of feature'
        cp, x=x, y=y
        ch1=round(x)                 <span class="comments">;scientific round</span>
        wait,0.5
        print, 'Left click RIGHT edge of feature'
        cp, x=x, y=y
        ch2=round(x)
        flag,[ch1,ch2], linestyle=1
        print,ch1,ch2,'chn'
        wait,0.5

        <span class="comments">;;flux</span>
        w=abs(velarr[ch1]-velarr[ch2])
        vch=0.5*(ch1+ch2)
        dv=abs(velarr[vch]-velarr[vch+1]) <span class="comments">;channel width in km/s</span>
        dv_smo=dv*sqrt(smo*smo+2.0*2.0)   <span class="comments">; vel. res. of Hanning + boxcar smoothed spectrum</span>
        print, ''
        print, 'channels 1,2 ', ch1,ch2
        print, 'total spec ', total(spec[ch1:ch2])
        print, ''
        print, 'w = ', w, ' km/s'
        print, ''
        totS=double(total(spec[ch1:ch2])*dv)
        totSerr=double(rms*dv*sqrt(ch2-ch1))
        totSerr_S05=double(2.*rms*sqrt(1.4*w*dv_smo)) <span class="comments">; CU HI archive definition (Springob+ 2005, eqn. 2)</span>
        peakS=double(max(spec[ch1:ch2]))
        print,'Serr ',totSerr
        print,'Serr S05 ',totSerr_S05

        <span class="comments">; SYSTEMATIC ERROR CAUSED BY CHOICE OF SIGNAL BOUNDARIES</span>
        totSerr_sys=double(0.)
        totSerr_tot=double(0.)
        <span class="comments">; print, "Estimate systematic errors caused by choice of signal boundaries "</span>
        <span class="comments">; print,'Flag new boundary edges: '</span>
        <span class="comments">; print, 'Left click LEFT edge '</span>
        <span class="comments">; cp, x=x, y=y</span>
        chn1=-1
        <span class="comments">; wait,0.5</span>
        <span class="comments">; print, 'Left click RIGHT edge '</span>
        <span class="comments">; cp, x=x, y=y</span>
        chn2=x
        <span class="comments">; flag,[chn1,chn2], linestyle=1</span>
        wait,0.5
        <span class="comments">; totSerr_sys= abs(totS- total(spec[chn1:chn2])*dv)/2. ; mJy km/s</span>
        <span class="comments">; totSerr_tot=sqrt(totSerr_S05^2+totSerr_sys^2)</span>
        
        exitmeasure: 
        smofac=W/(2.*dv_smo)            <span class="comments">; dv_smo= 10 km/s for ALFALFA, after han</span>
        if (W gt 400.) then  smofac=400./(2.*dv_smo)
        stn=fltarr(4)
        stn[0]=(totS/W)*sqrt(smofac)/rms <span class="comments">; ALFALFA definition, width just width</span>

        IF (detflag eq 'y') THEN stn[1]=peakS/rms

        print,'------------------------------------------------------------'
        print,' MEASURES '
        print,'------------------------------------------------------------'
        print,'n obj',nused
        print,' S/N [ALFALFA]:        ',stn[0]
        print,' S/N [peak/rms]:       ',stn[1]
        print,'------------------------------------------------------------'
       
        case stack.hd.input[2] of    <span class="comments">;which quantity has been stacked</span>
        1: begin                  <span class="comments">;flux</span>
            print,'flux [Jy]',totS/1000. ,' +/- ',totSerr_tot/1000. 
            <span class="comments">;;fill in structure</span>
            stack.S.totS=totS
            stack.S.totSerr_sys3totSerr_sys
            stack.S.totSerr=totSerr_tot
            stack.spec.flx=spec
            stack.rms[2]=rms
            stack.rms[3]=rms/sqrt(150./dv_smo)
            stack.sn.flx=stn[0:1]
        end
        2: begin                   <span class="comments">;mhi</span>
            mhi=double(2.356*10^4*10*totS/1000.) 
            mhi_err=double(2.356*10^4*10*totSerr_tot/1000.)
            print,'M_HI [M_sun]', mhi,' +/- ',mhi_err
            <span class="comments">;;fill in structure</span>
            stack.MHI.totMHI=mhi
            stack.MHI.totMHIerr_sys=double(2.356*10^4*10*totSerr_sys/1000.)
            stack.MHI.totMHIerr= mhi_err
            stack.spec.mhi=spec
            stack.rms_mhi[0]=rms
            stack.rms_mhi[1]=rms/sqrt(150./dv_smo)
            stack.sn.mhi=stn[0:1]  
        end
        3: begin                   <span class="comments">;mhi/m*</span>
            gf=double(2.356*10^4*10*totS/1000.)
            print,'TotS', totS
            gf_err=double(2.356*10^4*10*totSerr_tot/1000.)
            print,'M_HI/M* ',gf ,' +/- ',gf_err
            <span class="comments">;;fill in structure</span>
            stack.GF.totGF=gf
            print,'LOG(M_HI/M*) ',ALOG10(stack.GF.totGF) ,' +/- ',gf_err
            <span class="comments">; stack.GF.totGFerr_sys=double(2.356*10^4*10*totSerr_sys/1000.)</span>
            stack.GF.totGFerr=gf_err 
            stack.spec.gf=spec
            stack.rms_gf[0]=rms
            stack.rms_gf[1]=rms/sqrt(150./dv_smo)
            stack.sn.gf=stn[0:1]
            stack.detflag=detflag_n
        end
        endcase
      
        print,'------------------------------------------------------------'

        IF (detflag eq 'n') THEN stack.red.edge=[0,0] ELSE stack.red.edge=[ch1,ch2]        
        IF (detflag eq 'n') THEN stack.red.edge_err=[0,0] ELSE stack.red.edge_err=[chn1,chn2]
        stack.red.bmask=bmask
        stack.red.bord=norder
        stack.red.smooth=smo
        exitred:

        save,stack,file=file

        <span class="comments">;;Update Log file </span>
        print,'Reduction info appended to ', logFile

        openu,lun,logFile ,/get_lun,/append <span class="comments">; open the data file 4 update</span>
        printf, lun,' '
        printf, lun, '-------------------------------------------------'
        printf, lun,'REDUCTION INFO'
        printf, lun,norder,format="('Baseline pol:  ',i2)"
        printf, lun,smo,format="('Boxcar smoothing:  ',i2)"
        printf, lun,stn[0],format="('S/N [ALFALFA]:  ',f4.1)"
         IF (detflag eq 'y') THEN printf, lun,ch1,ch2,format="('Signal edges [channels]:  ',i4,' - ',i4)"
        case stack.hd.input[2] of    <span class="comments">;which quantity has been stacked</span>
            1: printf, lun,totS/1000.,totSerr_tot/1000.,format="('Measured flux [Jy]:  ',f6.2,' +/-',f6.2)"
            2: printf, lun,mhi,mhi_err,format="('Measured M_HI [Msun]:  ',e10.2,' +/-',e10.2)"
            3: printf, lun,gf,gf_err,format="('Measured M_HI/M*:  ',f5.3,' +/-',f5.3)"
        endcase
        if (stack.hd.input[3] eq 1) then printf, lun,stack.c_factor[1],format="('Correction for confusion (gf): ',f6.4)"

        close,lun, /ALL

        nogalaxies:

    endfor
endfor
end
</code>
    </div>
  </body>
</html>